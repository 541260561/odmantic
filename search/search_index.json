{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ODMantic Documentation : https://art049.github.io/odmantic/ ODMantic is an Object Document Mapper (a kind of ORM but for NoSQL databases) for MongoDB based on standard python type hints. It's built on top of pydantic for model definition and validation. Core features: Simple : define your model by typing your fields using python types, build queries using python comparison operators Developer experience : field/method autocompletion, type hints, data validation Fully typed : leverage static analysis to reduce runtime issues AsyncIO : works well with ASGI frameworks ( FastAPI , Starlette , ...) Serialization : built in JSON serialization and JSON schema generation Requirements \u00b6 Python : 3.6 and later (tested against 3.6, 3.7 and 3.8) MongoDB : 4.0 and later Two direct dependencies: pydantic : makes data validation and schema definition both handy and elegant. motor : an asyncio MongoDB driver officially developed by the MongoDB team. Installation \u00b6 pip install odmantic Example \u00b6 To enjoy an async context without any code boilerplate, you can reproduce the following steps using the AsyncIO REPL (only for Python 3.8+). python3.8 -m asyncio If you are using an earlier version of Python you can use IPython which provide an Autoawait feature (starting from Python 3.6). Define your first model \u00b6 from typing import Optional from odmantic import Field , Model class Publisher ( Model ): name : str founded : int = Field ( ge = 1440 ) location : Optional [ str ] = None By defining the Publisher class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers. This model contains three fields: name : This is the name of the Publisher. This is a simple string field without any specific validation but it will be required to build a new Publisher. founded : This is the year of foundation of the Publisher. Since the printing press has been invented in 1440, it would be handy to allow only values above 1440. The ge keyword argument passed to the Field is exactly doing this. The model will require a founded value greater or equal than 1440. location : This field will contain the country code of the Publisher. Defining this field as Optional with a None default value makes it a non required field that will be set automatically when not specified. The collection name has been defined by ODMantic as well. In this case it will be publisher . Create some instances \u00b6 instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] We defined three instances of the Publisher model. They all have a name property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to None (it will be stored as null in the database). For now, those instances only exists locally. We will persist them in a database in the next step. Populate the database with your instances \u00b6 For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container). docker run --rm --net = host mongo First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object. from odmantic import AIOEngine engine = AIOEngine () By default, the AIOEngine (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named test by default. The next step is to persist the instances we created before. We can perform this operation using the AIOEngine.save_all method. await engine . save_all ( instances ) Most of the engine I/O methods are asynchronous, hence the await keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface. Another possibility is to use mongo CLI directly: mongo --eval \"db.publisher.find({})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54c9\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54ca\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : null , \"name\" : \"Lulu\" } The created instances are stored in the test database under the publisher collection. We can see that an _id field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name id . print ( instances [ 0 ] . id ) #> ObjectId(\"5f67b331514d6855bc5c54c9\") Find instances matching a criteria \u00b6 Since we now have some documents in the database, we can start building some queries. First, let's find publishers created before the 2000s: early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] Here, we called the engine.find method. The first argument we need to specify is the Model class we want to query on (in our case Publisher ). The second argument is the actual query. Similarly to SQLAlchemy , you can build ODMantic queries using the regular python operators. When awaited, the engine.find method will return the list of matching instances stored in the database. Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA): ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Here the result is None because no matching instances have been found in the database. The engine.find_one method returns an instance if one exists in the database otherwise, it will return None . Modify an instance \u00b6 Finally, let's edit some instances. For example, we can set the location for the publisher named Lulu . First, we need to gather the instance from the database: lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=None) We still have the same instance, with no location set. We can change this field: lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) The location has been changed locally but the last step to persist this change is to save the document: await engine . save ( lulu ) We can now check the database state: mongo --eval \"db.publisher.find({name: 'Lulu'})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : \"US\" , \"name\" : \"Lulu\" } The document have been successfully updated ! Now, what if we would like to change the foundation date with an invalid one (before 1440) ? lulu . founded = 1000 #> ValidationError: 1 validation error for Publisher #> founded #> ensure this value is greater than 1440 #> (type=value_error.number.not_gt; limit_value=1440) This will raise an exception as it's not matching the model definition. The raised exception is actually a ValidationError created by from pydantic . To get started on more advanced practices like relations and building more advanced queries, you can check the documentation . License \u00b6 This project is licensed under the terms of the ISC license .","title":"Overview"},{"location":"#requirements","text":"Python : 3.6 and later (tested against 3.6, 3.7 and 3.8) MongoDB : 4.0 and later Two direct dependencies: pydantic : makes data validation and schema definition both handy and elegant. motor : an asyncio MongoDB driver officially developed by the MongoDB team.","title":"Requirements"},{"location":"#installation","text":"pip install odmantic","title":"Installation"},{"location":"#example","text":"To enjoy an async context without any code boilerplate, you can reproduce the following steps using the AsyncIO REPL (only for Python 3.8+). python3.8 -m asyncio If you are using an earlier version of Python you can use IPython which provide an Autoawait feature (starting from Python 3.6).","title":"Example"},{"location":"#define-your-first-model","text":"from typing import Optional from odmantic import Field , Model class Publisher ( Model ): name : str founded : int = Field ( ge = 1440 ) location : Optional [ str ] = None By defining the Publisher class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers. This model contains three fields: name : This is the name of the Publisher. This is a simple string field without any specific validation but it will be required to build a new Publisher. founded : This is the year of foundation of the Publisher. Since the printing press has been invented in 1440, it would be handy to allow only values above 1440. The ge keyword argument passed to the Field is exactly doing this. The model will require a founded value greater or equal than 1440. location : This field will contain the country code of the Publisher. Defining this field as Optional with a None default value makes it a non required field that will be set automatically when not specified. The collection name has been defined by ODMantic as well. In this case it will be publisher .","title":"Define your first model"},{"location":"#create-some-instances","text":"instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] We defined three instances of the Publisher model. They all have a name property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to None (it will be stored as null in the database). For now, those instances only exists locally. We will persist them in a database in the next step.","title":"Create some instances"},{"location":"#populate-the-database-with-your-instances","text":"For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container). docker run --rm --net = host mongo First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object. from odmantic import AIOEngine engine = AIOEngine () By default, the AIOEngine (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named test by default. The next step is to persist the instances we created before. We can perform this operation using the AIOEngine.save_all method. await engine . save_all ( instances ) Most of the engine I/O methods are asynchronous, hence the await keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface. Another possibility is to use mongo CLI directly: mongo --eval \"db.publisher.find({})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54c9\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54ca\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : null , \"name\" : \"Lulu\" } The created instances are stored in the test database under the publisher collection. We can see that an _id field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name id . print ( instances [ 0 ] . id ) #> ObjectId(\"5f67b331514d6855bc5c54c9\")","title":"Populate the database with your instances"},{"location":"#find-instances-matching-a-criteria","text":"Since we now have some documents in the database, we can start building some queries. First, let's find publishers created before the 2000s: early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] Here, we called the engine.find method. The first argument we need to specify is the Model class we want to query on (in our case Publisher ). The second argument is the actual query. Similarly to SQLAlchemy , you can build ODMantic queries using the regular python operators. When awaited, the engine.find method will return the list of matching instances stored in the database. Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA): ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Here the result is None because no matching instances have been found in the database. The engine.find_one method returns an instance if one exists in the database otherwise, it will return None .","title":"Find instances matching a criteria"},{"location":"#modify-an-instance","text":"Finally, let's edit some instances. For example, we can set the location for the publisher named Lulu . First, we need to gather the instance from the database: lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=None) We still have the same instance, with no location set. We can change this field: lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) The location has been changed locally but the last step to persist this change is to save the document: await engine . save ( lulu ) We can now check the database state: mongo --eval \"db.publisher.find({name: 'Lulu'})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : \"US\" , \"name\" : \"Lulu\" } The document have been successfully updated ! Now, what if we would like to change the foundation date with an invalid one (before 1440) ? lulu . founded = 1000 #> ValidationError: 1 validation error for Publisher #> founded #> ensure this value is greater than 1440 #> (type=value_error.number.not_gt; limit_value=1440) This will raise an exception as it's not matching the model definition. The raised exception is actually a ValidationError created by from pydantic . To get started on more advanced practices like relations and building more advanced queries, you can check the documentation .","title":"Modify an instance"},{"location":"#license","text":"This project is licensed under the terms of the ISC license .","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . 0.1.0 - 2020-10-?? \u00b6 Initial Release \u00b6","title":"Changelog"},{"location":"changelog/#changelog","text":"The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#010-2020-10-","text":"","title":"0.1.0 - 2020-10-??"},{"location":"changelog/#initial-release","text":"","title":"Initial Release"},{"location":"contributing/","text":"Contributing \u00b6 Local development \u00b6 Installing the tools \u00b6 Docker : used to run a local MongoDB instance Task : task manager Installing python based development tools In order to install the devtools written in python, it's recommended to use pipx . python3 -m pip install --user pipx python3 -m pipx ensurepath Poetry : packaging system and dependency manager pipx install poetry tox : multi-environment test runner pipx install tox pre-commit : pre commit hook manager pipx install pre-commit Python versions If you want to test the project with multiple python versions, you'll need to install them manually. You can use pyenv to install them easily. pyenv install \"3.6.12\" pyenv install \"3.7.9\" pyenv install \"3.8.9\" Configuring the local project \u00b6 task setup Developing \u00b6 Available tasks for the project: task setup : Configure the development environment. task lint : Run the linting checks. task format : Format the code (and imports). task mongodb-docker : Start the local MongoDB server. task test : Run the tests with the current version. task full-test : Run the tests against all supported versions. task coverage : Get the test coverage (xml and html) with the current version. task docs : Start the local documentation server.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#local-development","text":"","title":"Local development"},{"location":"contributing/#installing-the-tools","text":"Docker : used to run a local MongoDB instance Task : task manager Installing python based development tools In order to install the devtools written in python, it's recommended to use pipx . python3 -m pip install --user pipx python3 -m pipx ensurepath Poetry : packaging system and dependency manager pipx install poetry tox : multi-environment test runner pipx install tox pre-commit : pre commit hook manager pipx install pre-commit Python versions If you want to test the project with multiple python versions, you'll need to install them manually. You can use pyenv to install them easily. pyenv install \"3.6.12\" pyenv install \"3.7.9\" pyenv install \"3.8.9\"","title":"Installing the tools"},{"location":"contributing/#configuring-the-local-project","text":"task setup","title":"Configuring the local project"},{"location":"contributing/#developing","text":"Available tasks for the project: task setup : Configure the development environment. task lint : Run the linting checks. task format : Format the code (and imports). task mongodb-docker : Start the local MongoDB server. task test : Run the tests with the current version. task full-test : Run the tests against all supported versions. task coverage : Get the test coverage (xml and html) with the current version. task docs : Start the local documentation server.","title":"Developing"},{"location":"engine/","text":"Engine \u00b6 Creating the engine \u00b6 In the previous examples, we created the engine using default parameters: MongoDB: running on localhost port 27017 Database name: test It's possible to provide a custom AsyncIOMotorClient to the [AIOEngine][odmantic.engine.AIOEngine] constructor. In the same way, the database name can be changed using the database keyword argument. 1 2 3 4 5 6 from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , database = \"example_db\" ) For additional information about the MongoDB connection strings, see this section of the MongoDB documentation. Usage with DNS SRV records If you decide to use the DNS Seed List Connection Format (i.e mongodb+srv://... ), you will need to install the dnspython package. Create \u00b6 There are two ways of persisting instances to the database (i.e creating new documents): [AIOEngine.save][odmantic.engine.AIOEngine.save]: to save a single instance [AIOEngine.save_all][odmantic.engine.AIOEngine.save]: to save multiple instances at once 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) await engine . save ( leeroy ) players = [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] await engine . save_all ( players ) Resulting documents in the player collection { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Counter-Strike\" , \"name\" : \"Shroud\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Referenced instances When calling [AIOEngine.save][odmantic.engine.AIOEngine.save] or [AIOEngine.save_all][odmantic.engine.AIOEngine.save], the referenced models will be persisted as well. Read \u00b6 Examples database content The next examples will consider that you have a player collection populated with the documents previously created. Fetch a single instance \u00b6 As with regular MongoDB driver, you can use the [AIOEngine.find_one][odmantic.engine.AIOEngine.find_one] method to get at most one instance of a specific Model. This method will either return an instance matching the specified criteriums or None if no instances have been found. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player = await engine . find_one ( Player , Player . name == \"Serral\" ) print ( repr ( player )) #> Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\") another_player = await engine . find_one ( Player , Player . name == \"Player_Not_Stored_In_Database\" ) print ( another_player ) #> None Fetch multiple instances \u00b6 To get more than one instance from the database at once, you can use the [AIOEngine.find][odmantic.engine.AIOEngine.find] method. This method will return an [AIOCursor][odmantic.engine.AIOCursor] object, that can be used in two different ways. Usage as an async iterator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async for player in engine . find ( Player , Player . game == \"Starcraft\" ): print ( repr ( player )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') #> Player(id=ObjectId(...), name='Serral', game='Starcraft') Usage as an awaitable Even if the async iterator usage should be preferred, in some cases it might be required to gather all the documents from the database before processing them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player , Player . game != \"Starcraft\" ) print ( players ) #> [ #> Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"), #> Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"), #> ] Pagination You can as well use the skip and limit keyword arguments when using [AIOEngine.find][odmantic.engine.AIOEngine.find], respectively to skip a specified number of instances and to limit the number of fetched instances. Referenced instances When calling [AIOEngine.find][odmantic.engine.AIOEngine.find] or [AIOEngine.find_one][odmantic.engine.AIOEngine.find_one], the referenced models will be recursively resolved as well. Passing the model class to find and find_one When using the method to retrieve instances from the database, you have to specify the Model you want to query on as the first positional parameter. Internally, this enables ODMantic to properly type the results. Count instances \u00b6 You can count instances in the database by using the [AIOEngine.count][odmantic.engine.AIOEngine.count] method. It's possible as well to use this method with filtering queries. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_count = await engine . count ( Player ) print ( player_count ) #> 4 cs_count = await engine . count ( Player , Player . game == \"Counter-Strike\" ) print ( cs_count ) #> 1 valorant_count = await engine . count ( Player , Player . game == \"Valorant\" ) print ( valorant_count ) #> 0 Combining multiple queries in read operations While using [find][odmantic.engine.AIOEngine.find], [find_one][odmantic.engine.AIOEngine.find_one] or [count][odmantic.engine.AIOEngine.count], you may pass as many queries as you want as positional arguments. Those will be implicitly combined as single [and_][odmantic.query.and_] query. Update \u00b6 Updating an instance in the database can be done simply by modifying the instance locally and saving it again to the database. The [AIOEngine.save][odmantic.engine.AIOEngine.save] and [AIOEngine.save_all][odmantic.engine.AIOEngine.save] methods are actually behaving as upsert operations. In other words, if the instance already exists it will be updated. Otherwise, the related document will be created in the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . game ) #> Counter-Strike shroud . game = \"Valorant\" await engine . save ( shroud ) Resulting documents in the player collection { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Primary field update Currently, changing the primary field value is disabled and a NotImplementedError exception will be raised if you try to do so. It is still possible to mutate the primary field if the field type is mutable but it might result in unexpected behaviors. Workaround to modify the primary key There is still a workaround to update the primary key of a document: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from bson import ObjectId from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . id ) #> 5f86074f6dfecacc68428a62 new_id = ObjectId ( \"ffffffffffffffffffffffff\" ) # First delete the remote instance await engine . delete ( shroud ) # Then, copy the player object with a new primary key new_shroud = Player ( ** { ** shroud . dict (), \"id\" : new_id }) # Finally create again the document await engine . save ( new_shroud ) Resulting document associated to the player { \"_id\" : ObjectId( \"ffffffffffffffffffffffff\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } Delete \u00b6 You can delete instance by passing them to the [AIOEngine.delete][odmantic.engine.AIOEngine.delete] method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player ) for player in players : await engine . delete ( player ) The collection is now empty .","title":"Engine"},{"location":"engine/#engine","text":"","title":"Engine"},{"location":"engine/#creating-the-engine","text":"In the previous examples, we created the engine using default parameters: MongoDB: running on localhost port 27017 Database name: test It's possible to provide a custom AsyncIOMotorClient to the [AIOEngine][odmantic.engine.AIOEngine] constructor. In the same way, the database name can be changed using the database keyword argument. 1 2 3 4 5 6 from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , database = \"example_db\" ) For additional information about the MongoDB connection strings, see this section of the MongoDB documentation. Usage with DNS SRV records If you decide to use the DNS Seed List Connection Format (i.e mongodb+srv://... ), you will need to install the dnspython package.","title":"Creating the engine"},{"location":"engine/#create","text":"There are two ways of persisting instances to the database (i.e creating new documents): [AIOEngine.save][odmantic.engine.AIOEngine.save]: to save a single instance [AIOEngine.save_all][odmantic.engine.AIOEngine.save]: to save multiple instances at once 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) await engine . save ( leeroy ) players = [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] await engine . save_all ( players ) Resulting documents in the player collection { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Counter-Strike\" , \"name\" : \"Shroud\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Referenced instances When calling [AIOEngine.save][odmantic.engine.AIOEngine.save] or [AIOEngine.save_all][odmantic.engine.AIOEngine.save], the referenced models will be persisted as well.","title":"Create"},{"location":"engine/#read","text":"Examples database content The next examples will consider that you have a player collection populated with the documents previously created.","title":"Read"},{"location":"engine/#fetch-a-single-instance","text":"As with regular MongoDB driver, you can use the [AIOEngine.find_one][odmantic.engine.AIOEngine.find_one] method to get at most one instance of a specific Model. This method will either return an instance matching the specified criteriums or None if no instances have been found. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player = await engine . find_one ( Player , Player . name == \"Serral\" ) print ( repr ( player )) #> Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\") another_player = await engine . find_one ( Player , Player . name == \"Player_Not_Stored_In_Database\" ) print ( another_player ) #> None","title":"Fetch a single instance"},{"location":"engine/#fetch-multiple-instances","text":"To get more than one instance from the database at once, you can use the [AIOEngine.find][odmantic.engine.AIOEngine.find] method. This method will return an [AIOCursor][odmantic.engine.AIOCursor] object, that can be used in two different ways.","title":"Fetch multiple instances"},{"location":"engine/#count-instances","text":"You can count instances in the database by using the [AIOEngine.count][odmantic.engine.AIOEngine.count] method. It's possible as well to use this method with filtering queries. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_count = await engine . count ( Player ) print ( player_count ) #> 4 cs_count = await engine . count ( Player , Player . game == \"Counter-Strike\" ) print ( cs_count ) #> 1 valorant_count = await engine . count ( Player , Player . game == \"Valorant\" ) print ( valorant_count ) #> 0 Combining multiple queries in read operations While using [find][odmantic.engine.AIOEngine.find], [find_one][odmantic.engine.AIOEngine.find_one] or [count][odmantic.engine.AIOEngine.count], you may pass as many queries as you want as positional arguments. Those will be implicitly combined as single [and_][odmantic.query.and_] query.","title":"Count instances"},{"location":"engine/#update","text":"Updating an instance in the database can be done simply by modifying the instance locally and saving it again to the database. The [AIOEngine.save][odmantic.engine.AIOEngine.save] and [AIOEngine.save_all][odmantic.engine.AIOEngine.save] methods are actually behaving as upsert operations. In other words, if the instance already exists it will be updated. Otherwise, the related document will be created in the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . game ) #> Counter-Strike shroud . game = \"Valorant\" await engine . save ( shroud ) Resulting documents in the player collection { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Primary field update Currently, changing the primary field value is disabled and a NotImplementedError exception will be raised if you try to do so. It is still possible to mutate the primary field if the field type is mutable but it might result in unexpected behaviors. Workaround to modify the primary key There is still a workaround to update the primary key of a document: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from bson import ObjectId from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . id ) #> 5f86074f6dfecacc68428a62 new_id = ObjectId ( \"ffffffffffffffffffffffff\" ) # First delete the remote instance await engine . delete ( shroud ) # Then, copy the player object with a new primary key new_shroud = Player ( ** { ** shroud . dict (), \"id\" : new_id }) # Finally create again the document await engine . save ( new_shroud ) Resulting document associated to the player { \"_id\" : ObjectId( \"ffffffffffffffffffffffff\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" }","title":"Update"},{"location":"engine/#delete","text":"You can delete instance by passing them to the [AIOEngine.delete][odmantic.engine.AIOEngine.delete] method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player ) for player in players : await engine . delete ( player ) The collection is now empty .","title":"Delete"},{"location":"fields/","text":"Fields \u00b6 The id field \u00b6 The ObjectId data type is the default primary key type used by MongoDB. An ObjectId comes with many information embedded into it (timestamp, machine identifier, ...). Since by default MongoDB will create a field _id containing an ObjectId primary key, ODMantic will bind it automatically to an implicit field named id . 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( leeroy . id ) #> ObjectId('5ed50fcad11d1975aa3d7a28') print ( repr ( leeroy )) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\") ObjectId creation This id field will be generated on instance creation, before saving the instance to the database. This helps to keep consistency between the instances persisted to the database and the ones only created locally. Even if this behavior is convenient, it is still possible to define custom primary keys . Field types \u00b6 Optional fields \u00b6 By default, every single field will be required. To specify a field as non-required, the easiest way is to use the typing.Optional generic type that will allow the field to take the None value as well (it will be stored as null in the database). 1 2 3 4 5 6 7 8 9 10 11 12 from typing import Optional from odmantic import Model class Person ( Model ): name : str age : Optional [ int ] john = Person ( name = \"John\" ) print ( john . age ) #> None Union fields \u00b6 As explained in the Python Typing documentation , Optional[X] is equivalent to Union[X, None] . That implies that the field type will be either X or None . It's possible to combine any kind of type using the typ\u00eeng.Union type constructor. For example if we want to allow both string and int in a field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from typing import Union from odmantic import Model class Thing ( Model ): ref_id : Union [ int , str ] thing_1 = Thing ( ref_id = 42 ) print ( thing_1 . ref_id ) #> 42 thing_2 = Thing ( ref_id = \"i am a string\" ) print ( thing_2 . ref_id ) #> i am a string NoneType Internally python describes the type of the None object as NoneType but in practice, None is used directly in type annotations ( more details ). Enum fields \u00b6 To define choices, it's possible to use the standard enum classes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from enum import Enum from odmantic import AIOEngine , Model class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str kind : TreeKind sequoia = Tree ( name = \"Sequoia\" , kind = TreeKind . BIG ) print ( sequoia . kind ) #> TreeKind.BIG print ( sequoia . kind == \"big\" ) #> True spruce = Tree ( name = \"Spruce\" , kind = \"small\" ) print ( spruce . kind ) #> TreeKind.SMALL print ( spruce . kind == TreeKind . SMALL ) #> True engine = AIOEngine () await engine . save_all ([ sequoia , spruce ]) Resulting documents in the collection tree after execution { \"_id\" : ObjectId( \"5f818f2dd5708527282c49b6\" ) , \"kind\" : \"big\" , \"name\" : \"Sequoia\" } { \"_id\" : ObjectId( \"5f818f2dd5708527282c49b7\" ) , \"kind\" : \"small\" , \"name\" : \"Spruce\" } If you try to use a value not present in the allowed choices, a ValidationError exception will be raised. Usage of enum.auto If you might add some values to an Enum , it's strongly recommended not to use the enum.auto value generator. Depending on the order you add choices, it could completely break the consistency with documents stored in the database. Unwanted behavior example 1 2 3 4 5 6 7 8 9 10 11 12 from enum import Enum , auto class Color ( Enum ): RED = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . BLUE . value ) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from enum import Enum , auto class Color ( Enum ): RED = auto () GREEN = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . GREEN . value ) #> 2 print ( Color . BLUE . value ) #> 3 Container fields \u00b6 List 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import List , Union from odmantic import Model class SimpleListModel ( Model ): field : list print ( SimpleListModel ( field = [ 1 , \"a\" , True ]) . field ) #> [1, 'a', True] print ( SimpleListModel ( field = ( 1 , \"a\" , True )) . field ) #> [1, 'a', True] class IntListModel ( Model ): field : List [ int ] print ( IntListModel ( field = [ 1 , 5 ]) . field ) #> [1, 5] print ( IntListModel ( field = ( 1 , 5 )) . field ) #> [1, 5] class IntStrListModel ( Model ): field : List [ Union [ int , str ]] print ( IntStrListModel ( field = [ 1 , \"b\" ]) . field ) #> [1, 'b'] print ( IntStrListModel ( field = ( 1 , \"b\" )) . field ) #> [1, 'b'] Tip It's possible to define element count constraints for a list field using the [Field][odmantic.field.Field] descriptor. Tuple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import Tuple from odmantic import Model class SimpleTupleModel ( Model ): field : tuple print ( SimpleTupleModel ( field = [ 1 , \"a\" , True ]) . field ) #> (1, 'a', True) print ( SimpleTupleModel ( field = ( 1 , \"a\" , True )) . field ) #> (1, 'a', True) class TwoIntTupleModel ( Model ): field : Tuple [ int , int ] print ( SimpleTupleModel ( field = ( 1 , 10 )) . field ) #> (1, 10) print ( SimpleTupleModel ( field = [ 1 , 10 ]) . field ) #> (1, 10) class IntTupleModel ( Model ): field : Tuple [ int , ... ] print ( IntTupleModel ( field = ( 1 ,)) . field ) #> (1,) print ( IntTupleModel ( field = [ 1 , 2 , 3 , 10 ]) . field ) #> (1, 2, 3, 10) Dict Tip For mapping types with already known keys, you can see the embedded models section . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from typing import Dict , Union from odmantic import Model class SimpleDictModel ( Model ): field : dict print ( SimpleDictModel ( field = { 18 : \"a string\" , True : 42 , 18.3 : [ 1 , 2 , 3 ]}) . field ) #> {18: 'a string', True: 42, 18.3: [1, 2, 3]} class IntStrDictModel ( Model ): field : Dict [ int , str ] print ( IntStrDictModel ( field = { 1 : \"one\" , 2 : \"two\" }) . field ) #> {1: 'one', 2: 'two'} class IntBoolStrDictModel ( Model ): field : Dict [ int , Union [ bool , str ]] print ( IntBoolStrDictModel ( field = { 0 : False , 1 : True , 3 : \"three\" }) . field ) #> {0: False, 1: True, 3: 'three'} Performance tip Whenever possible, try to avoid mutable container types ( List , Set , ...) and prefer their Immutable alternatives ( Tuple , FrozenSet , ...). This will allow ODMantic to speedup database writes by only saving the modified container fields. BSON types integration \u00b6 ODMantic supports native python BSON types ( bson package ). Those types can be used directly as field types: bson.ObjectId bson.Int64 bson.Decimal128 bson.Regex bson.Binary Generic python to BSON type map Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal decimal str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array Pydantic fields \u00b6 Most of the types supported by pydantic are supported by ODMantic. See pydantic: Field Types for more field types. Unsupported fields: typing.Callable Fields with a specific behavior: datetime.datetime : Only naive datetime objects will be allowed as MongoDB doesn't store the timezone information. Also, the microsecond information will be truncated. Customization \u00b6 The field customization can mainly be performed using the [Field][odmantic.field.Field] descriptor. This descriptor is here to define everything about the field except its type. Default values \u00b6 The easiest way to set a default value to a field is by assigning this default value directly while defining the model. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cd4be16af832772f1615e'), name='Dash', level=0) You can combine default values and an existing [Field][odmantic.field.Field] descriptor using the default keyword argument. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Field , Model class Player ( Model ): name : str level : int = Field ( default = 1 , ge = 1 ) p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cdbfbb54a94e9e8717c77'), name='Dash', level=1) Default factory You may as well define a factory function instead of a value using the default_factory argument of the [Field][odmantic.field.Field] descriptor. Tip For typing.Optional fields, None is already set as the default value Default values validation Currently the default values are not validated yet during the model creation. An inconsistent default value might raise a ValidationError while building an instance. Document structure \u00b6 By default, the MongoDB documents fields will be named after the field name. It is possible to override this naming policy by using the key_name argument in the [Field][odmantic.field.Field] descriptor. 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( key_name = \"username\" ) engine = AIOEngine () await engine . save ( Player ( name = \"Jack\" )) Resulting documents in the collection player after execution { \"_id\" : ObjectId( \"5ed50fcad11d1975aa3d7a28\" ) , \"username\" : \"Jack\" , } See this section for more details about the _id field that has been added. Primary key \u00b6 While ODMantic will by default populate the id field as a primary key, you can use any other field as the primary key. 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( repr ( leeroy )) #> Player(name=\"Leeroy Jenkins\") engine = AIOEngine () await engine . save ( leeroy ) Resulting documents in the collection player after execution { \"_id\" : \"Leeroy Jenkins\" } Info The Mongo name of the primary field will be enforced to _id and you will not be able to change it. Warning Using mutable types (Set, List, ...) as primary field might result in inconsistent behaviors. Validation \u00b6 As ODMantic strongly relies on pydantic when it comes to data validation, most of the validation features provided by pydantic are available: Add field validation constraints by using the [Field descriptor][odmantic.field.Field] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from typing import List from odmantic import Field , Model class ExampleModel ( Model ): small_int : int = Field ( le = 10 ) big_int : int = Field ( gt = 1000 ) even_int : int = Field ( multiple_of = 2 ) small_float : float = Field ( lt = 10 ) big_float : float = Field ( ge = 1e10 ) short_string : str = Field ( max_length = 10 ) long_string : str = Field ( min_length = 100 ) string_starting_with_the : str = Field ( regex = r \"^The\" ) short_str_list : List [ str ] = Field ( max_items = 5 ) long_str_list : List [ str ] = Field ( min_items = 15 ) Use strict types to prevent to coercion from compatible types ( pydantic: Strict Types ) 1 2 3 4 5 6 7 8 9 from pydantic import StrictBool , StrictFloat , StrictStr from odmantic import Model class ExampleModel ( Model ): strict_bool : StrictBool strict_float : StrictFloat strict_str : StrictStr Define custom field validators ( pydantic: Validators ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from typing import ClassVar from pydantic import ValidationError , validator from odmantic import Model class SmallRectangle ( Model ): MAX_SIDE_SIZE : ClassVar [ float ] = 10 length : float width : float @validator ( \"width\" , \"length\" ) def check_small_sides ( cls , v ): if v > cls . MAX_SIDE_SIZE : raise ValueError ( f \"side is greater than { cls . MAX_SIDE_SIZE } \" ) return v @validator ( \"width\" ) def check_width_length ( cls , width , values , ** kwargs ): length = values . get ( \"length\" ) if length is not None and width > length : raise ValueError ( \"width can't be greater than length\" ) return width print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 40 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle length side is greater than 10 (type=value_error) \"\"\" Define custom model validators: more details Custom field types \u00b6 Exactly in the same way pydantic allows it, it's possible to define custom field types as well with ODMantic ( pydantic: Custom data types ). Sometimes, it might be required to customize as well the field BSON serialization. In order to do this, the field class will have to implement the __bson__ class method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from bson import Binary from odmantic import AIOEngine , Model class ASCIISerializedAsBinary ( str ): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , v ): if isinstance ( v , bytes ): # Handle data coming from MongoDB return v . decode ( \"ascii\" ) if not isinstance ( v , str ): raise TypeError ( \"string required\" ) if not v . isascii (): raise ValueError ( \"Only ascii characters are allowed\" ) return v @classmethod def __bson__ ( cls , v : str ): # We can encode this string as ascii since it contains # only ascii characters bytes_ = v . encode ( \"ascii\" ) return bytes_ class Example ( Model ): field : ASCIISerializedAsBinary engine = AIOEngine () await engine . save ( Example ( field = \"hello world\" )) fetched = await engine . find_one ( Example ) print ( fetched . field ) #> hello world In this example, we decide to store string data manually encoded in the ASCII encoding. The encoding is handled in the __bson__ class method. On top of this, we handle the decoding by attempting to decode bytes object in the validate method. Resulting documents in the collection example after execution { \"_id\" : ObjectId( \"5f81fa5e8adaf4bf33f05035\" ) , \"field\" : BinData( 0 , \"aGVsbG8gd29ybGQ=\" ) } Warning When using custom bson serialization, it's important to handle as well the data validation for data retrieved from Mongo. In the previous example it's done by handling bytes objects in the validate method.","title":"Fields"},{"location":"fields/#fields","text":"","title":"Fields"},{"location":"fields/#the-id-field","text":"The ObjectId data type is the default primary key type used by MongoDB. An ObjectId comes with many information embedded into it (timestamp, machine identifier, ...). Since by default MongoDB will create a field _id containing an ObjectId primary key, ODMantic will bind it automatically to an implicit field named id . 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( leeroy . id ) #> ObjectId('5ed50fcad11d1975aa3d7a28') print ( repr ( leeroy )) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\") ObjectId creation This id field will be generated on instance creation, before saving the instance to the database. This helps to keep consistency between the instances persisted to the database and the ones only created locally. Even if this behavior is convenient, it is still possible to define custom primary keys .","title":"The id field"},{"location":"fields/#field-types","text":"","title":"Field types"},{"location":"fields/#optional-fields","text":"By default, every single field will be required. To specify a field as non-required, the easiest way is to use the typing.Optional generic type that will allow the field to take the None value as well (it will be stored as null in the database). 1 2 3 4 5 6 7 8 9 10 11 12 from typing import Optional from odmantic import Model class Person ( Model ): name : str age : Optional [ int ] john = Person ( name = \"John\" ) print ( john . age ) #> None","title":"Optional fields"},{"location":"fields/#union-fields","text":"As explained in the Python Typing documentation , Optional[X] is equivalent to Union[X, None] . That implies that the field type will be either X or None . It's possible to combine any kind of type using the typ\u00eeng.Union type constructor. For example if we want to allow both string and int in a field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from typing import Union from odmantic import Model class Thing ( Model ): ref_id : Union [ int , str ] thing_1 = Thing ( ref_id = 42 ) print ( thing_1 . ref_id ) #> 42 thing_2 = Thing ( ref_id = \"i am a string\" ) print ( thing_2 . ref_id ) #> i am a string NoneType Internally python describes the type of the None object as NoneType but in practice, None is used directly in type annotations ( more details ).","title":"Union fields"},{"location":"fields/#enum-fields","text":"To define choices, it's possible to use the standard enum classes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from enum import Enum from odmantic import AIOEngine , Model class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str kind : TreeKind sequoia = Tree ( name = \"Sequoia\" , kind = TreeKind . BIG ) print ( sequoia . kind ) #> TreeKind.BIG print ( sequoia . kind == \"big\" ) #> True spruce = Tree ( name = \"Spruce\" , kind = \"small\" ) print ( spruce . kind ) #> TreeKind.SMALL print ( spruce . kind == TreeKind . SMALL ) #> True engine = AIOEngine () await engine . save_all ([ sequoia , spruce ]) Resulting documents in the collection tree after execution { \"_id\" : ObjectId( \"5f818f2dd5708527282c49b6\" ) , \"kind\" : \"big\" , \"name\" : \"Sequoia\" } { \"_id\" : ObjectId( \"5f818f2dd5708527282c49b7\" ) , \"kind\" : \"small\" , \"name\" : \"Spruce\" } If you try to use a value not present in the allowed choices, a ValidationError exception will be raised. Usage of enum.auto If you might add some values to an Enum , it's strongly recommended not to use the enum.auto value generator. Depending on the order you add choices, it could completely break the consistency with documents stored in the database. Unwanted behavior example 1 2 3 4 5 6 7 8 9 10 11 12 from enum import Enum , auto class Color ( Enum ): RED = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . BLUE . value ) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from enum import Enum , auto class Color ( Enum ): RED = auto () GREEN = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . GREEN . value ) #> 2 print ( Color . BLUE . value ) #> 3","title":"Enum fields"},{"location":"fields/#container-fields","text":"","title":"Container fields"},{"location":"fields/#bson-types-integration","text":"ODMantic supports native python BSON types ( bson package ). Those types can be used directly as field types: bson.ObjectId bson.Int64 bson.Decimal128 bson.Regex bson.Binary Generic python to BSON type map Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal decimal str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array","title":"BSON types integration"},{"location":"fields/#pydantic-fields","text":"Most of the types supported by pydantic are supported by ODMantic. See pydantic: Field Types for more field types. Unsupported fields: typing.Callable Fields with a specific behavior: datetime.datetime : Only naive datetime objects will be allowed as MongoDB doesn't store the timezone information. Also, the microsecond information will be truncated.","title":"Pydantic fields"},{"location":"fields/#customization","text":"The field customization can mainly be performed using the [Field][odmantic.field.Field] descriptor. This descriptor is here to define everything about the field except its type.","title":"Customization"},{"location":"fields/#default-values","text":"The easiest way to set a default value to a field is by assigning this default value directly while defining the model. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cd4be16af832772f1615e'), name='Dash', level=0) You can combine default values and an existing [Field][odmantic.field.Field] descriptor using the default keyword argument. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Field , Model class Player ( Model ): name : str level : int = Field ( default = 1 , ge = 1 ) p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cdbfbb54a94e9e8717c77'), name='Dash', level=1) Default factory You may as well define a factory function instead of a value using the default_factory argument of the [Field][odmantic.field.Field] descriptor. Tip For typing.Optional fields, None is already set as the default value Default values validation Currently the default values are not validated yet during the model creation. An inconsistent default value might raise a ValidationError while building an instance.","title":"Default values"},{"location":"fields/#document-structure","text":"By default, the MongoDB documents fields will be named after the field name. It is possible to override this naming policy by using the key_name argument in the [Field][odmantic.field.Field] descriptor. 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( key_name = \"username\" ) engine = AIOEngine () await engine . save ( Player ( name = \"Jack\" )) Resulting documents in the collection player after execution { \"_id\" : ObjectId( \"5ed50fcad11d1975aa3d7a28\" ) , \"username\" : \"Jack\" , } See this section for more details about the _id field that has been added.","title":"Document structure"},{"location":"fields/#primary-key","text":"While ODMantic will by default populate the id field as a primary key, you can use any other field as the primary key. 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( repr ( leeroy )) #> Player(name=\"Leeroy Jenkins\") engine = AIOEngine () await engine . save ( leeroy ) Resulting documents in the collection player after execution { \"_id\" : \"Leeroy Jenkins\" } Info The Mongo name of the primary field will be enforced to _id and you will not be able to change it. Warning Using mutable types (Set, List, ...) as primary field might result in inconsistent behaviors.","title":"Primary key"},{"location":"fields/#validation","text":"As ODMantic strongly relies on pydantic when it comes to data validation, most of the validation features provided by pydantic are available: Add field validation constraints by using the [Field descriptor][odmantic.field.Field] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from typing import List from odmantic import Field , Model class ExampleModel ( Model ): small_int : int = Field ( le = 10 ) big_int : int = Field ( gt = 1000 ) even_int : int = Field ( multiple_of = 2 ) small_float : float = Field ( lt = 10 ) big_float : float = Field ( ge = 1e10 ) short_string : str = Field ( max_length = 10 ) long_string : str = Field ( min_length = 100 ) string_starting_with_the : str = Field ( regex = r \"^The\" ) short_str_list : List [ str ] = Field ( max_items = 5 ) long_str_list : List [ str ] = Field ( min_items = 15 ) Use strict types to prevent to coercion from compatible types ( pydantic: Strict Types ) 1 2 3 4 5 6 7 8 9 from pydantic import StrictBool , StrictFloat , StrictStr from odmantic import Model class ExampleModel ( Model ): strict_bool : StrictBool strict_float : StrictFloat strict_str : StrictStr Define custom field validators ( pydantic: Validators ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from typing import ClassVar from pydantic import ValidationError , validator from odmantic import Model class SmallRectangle ( Model ): MAX_SIDE_SIZE : ClassVar [ float ] = 10 length : float width : float @validator ( \"width\" , \"length\" ) def check_small_sides ( cls , v ): if v > cls . MAX_SIDE_SIZE : raise ValueError ( f \"side is greater than { cls . MAX_SIDE_SIZE } \" ) return v @validator ( \"width\" ) def check_width_length ( cls , width , values , ** kwargs ): length = values . get ( \"length\" ) if length is not None and width > length : raise ValueError ( \"width can't be greater than length\" ) return width print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 40 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle length side is greater than 10 (type=value_error) \"\"\" Define custom model validators: more details","title":"Validation"},{"location":"fields/#custom-field-types","text":"Exactly in the same way pydantic allows it, it's possible to define custom field types as well with ODMantic ( pydantic: Custom data types ). Sometimes, it might be required to customize as well the field BSON serialization. In order to do this, the field class will have to implement the __bson__ class method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from bson import Binary from odmantic import AIOEngine , Model class ASCIISerializedAsBinary ( str ): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , v ): if isinstance ( v , bytes ): # Handle data coming from MongoDB return v . decode ( \"ascii\" ) if not isinstance ( v , str ): raise TypeError ( \"string required\" ) if not v . isascii (): raise ValueError ( \"Only ascii characters are allowed\" ) return v @classmethod def __bson__ ( cls , v : str ): # We can encode this string as ascii since it contains # only ascii characters bytes_ = v . encode ( \"ascii\" ) return bytes_ class Example ( Model ): field : ASCIISerializedAsBinary engine = AIOEngine () await engine . save ( Example ( field = \"hello world\" )) fetched = await engine . find_one ( Example ) print ( fetched . field ) #> hello world In this example, we decide to store string data manually encoded in the ASCII encoding. The encoding is handled in the __bson__ class method. On top of this, we handle the decoding by attempting to decode bytes object in the validate method. Resulting documents in the collection example after execution { \"_id\" : ObjectId( \"5f81fa5e8adaf4bf33f05035\" ) , \"field\" : BinData( 0 , \"aGVsbG8gd29ybGQ=\" ) } Warning When using custom bson serialization, it's important to handle as well the data validation for data retrieved from Mongo. In the previous example it's done by handling bytes objects in the validate method.","title":"Custom field types"},{"location":"filtering/","text":"Filtering \u00b6 QueryExpression Comparison operators \u00b6 There are multiple ways of building [QueryExpression][odmantic.query.QueryExpression] objects with comparisons operators: Using python comparison operators between the field of the model and the desired value == , != , <= , < , >= , > Using the functions provided by the odmantic.query module [query.eq][odmantic.query.eq] [query.ne][odmantic.query.ne] [query.gt][odmantic.query.gt] [query.gte][odmantic.query.gte] [query.lt][odmantic.query.lt] [query.lte][odmantic.query.lte] [query.in_][odmantic.query.in_] [query.not_in][odmantic.query.not_in] Using methods of the model's field and the desired value field.eq field.ne field.gte field.gt field.lte field.lte field.in_ field.not_in Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers. Using equality operators with Enum fields enum query example Embedded documents queries enum query example Equal \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name == \"Spruce\" #> QueryExpression({'name': {'$eq': 'Spruce'}}) Tree . name . eq ( \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) query . eq ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) Filter the trees named \"Spruce\". Not Equal \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name != \"Spruce\" #> QueryExpression({'name': {'$ne': 'Spruce'}}) Tree . name . ne ( \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) query . ne ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) Filter the trees that are not named \"Spruce\". Less than (or equal to) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size < 2 #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size . lt ( 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) query . lt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size <= 2 #> QueryExpression({'average_size': {'$lte': 2}}) Tree . average_size . lte ( 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) query . lte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) Filter the trees that have a size that is less than (or equal to) 2. Greater than (or equal to) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size > 2 #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size . gt ( 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) query . gt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size >= 2 #> QueryExpression({'average_size': {'$gte': 2}}) Tree . average_size . gte ( 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) query . gte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) Filter the trees having a size that is greater than (or equal to) 2. Included in \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . in_ ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) query . in_ ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) Filter the trees named either \"Spruce\" or \"Pine\". Not included in \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) Filter the trees neither named \"Spruce\" nor \"Pine\". Evaluation operators \u00b6 Match (Regex) \u00b6 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model , query class Tree ( Model ): name : str Tree . name . match ( r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) query . match ( Tree . name , r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) Filter the trees with a name starting with \"Spruce\". Logical operators \u00b6 And \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) & ( Tree . size <= 2 ) #> QueryExpression( #> { #> \"$and\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$lte\": 2}}), #> ) #> } #> ) query . and_ ( Tree . name == \"Spruce\" , Tree . size <= 2 ) #> ... same output ... Filter the trees named Spruce with a size less than 2. Implicit AND When using [find][odmantic.engine.AIOEngine.find], [find_one][odmantic.engine.AIOEngine.find_one] or [count][odmantic.engine.AIOEngine.count], you can specify multiple queries as positional arguments and those will be implicitly combined with the AND operator. Or \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) Nor \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) Manual filtering \u00b6","title":"Filtering"},{"location":"filtering/#filtering","text":"QueryExpression","title":"Filtering"},{"location":"filtering/#comparison-operators","text":"There are multiple ways of building [QueryExpression][odmantic.query.QueryExpression] objects with comparisons operators: Using python comparison operators between the field of the model and the desired value == , != , <= , < , >= , > Using the functions provided by the odmantic.query module [query.eq][odmantic.query.eq] [query.ne][odmantic.query.ne] [query.gt][odmantic.query.gt] [query.gte][odmantic.query.gte] [query.lt][odmantic.query.lt] [query.lte][odmantic.query.lte] [query.in_][odmantic.query.in_] [query.not_in][odmantic.query.not_in] Using methods of the model's field and the desired value field.eq field.ne field.gte field.gt field.lte field.lte field.in_ field.not_in Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers. Using equality operators with Enum fields enum query example Embedded documents queries enum query example","title":"Comparison operators"},{"location":"filtering/#equal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name == \"Spruce\" #> QueryExpression({'name': {'$eq': 'Spruce'}}) Tree . name . eq ( \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) query . eq ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) Filter the trees named \"Spruce\".","title":"Equal"},{"location":"filtering/#not-equal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name != \"Spruce\" #> QueryExpression({'name': {'$ne': 'Spruce'}}) Tree . name . ne ( \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) query . ne ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) Filter the trees that are not named \"Spruce\".","title":"Not Equal"},{"location":"filtering/#less-than-or-equal-to","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size < 2 #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size . lt ( 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) query . lt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size <= 2 #> QueryExpression({'average_size': {'$lte': 2}}) Tree . average_size . lte ( 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) query . lte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) Filter the trees that have a size that is less than (or equal to) 2.","title":"Less than (or equal to)"},{"location":"filtering/#greater-than-or-equal-to","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size > 2 #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size . gt ( 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) query . gt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size >= 2 #> QueryExpression({'average_size': {'$gte': 2}}) Tree . average_size . gte ( 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) query . gte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) Filter the trees having a size that is greater than (or equal to) 2.","title":"Greater than (or equal to)"},{"location":"filtering/#included-in","text":"1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . in_ ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) query . in_ ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) Filter the trees named either \"Spruce\" or \"Pine\".","title":"Included in"},{"location":"filtering/#not-included-in","text":"1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) Filter the trees neither named \"Spruce\" nor \"Pine\".","title":"Not included in"},{"location":"filtering/#evaluation-operators","text":"","title":"Evaluation operators"},{"location":"filtering/#match-regex","text":"1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model , query class Tree ( Model ): name : str Tree . name . match ( r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) query . match ( Tree . name , r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) Filter the trees with a name starting with \"Spruce\".","title":"Match (Regex)"},{"location":"filtering/#logical-operators","text":"","title":"Logical operators"},{"location":"filtering/#and","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) & ( Tree . size <= 2 ) #> QueryExpression( #> { #> \"$and\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$lte\": 2}}), #> ) #> } #> ) query . and_ ( Tree . name == \"Spruce\" , Tree . size <= 2 ) #> ... same output ... Filter the trees named Spruce with a size less than 2. Implicit AND When using [find][odmantic.engine.AIOEngine.find], [find_one][odmantic.engine.AIOEngine.find_one] or [count][odmantic.engine.AIOEngine.count], you can specify multiple queries as positional arguments and those will be implicitly combined with the AND operator.","title":"And"},{"location":"filtering/#or","text":"1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}})","title":"Or"},{"location":"filtering/#nor","text":"1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}})","title":"Nor"},{"location":"filtering/#manual-filtering","text":"","title":"Manual filtering"},{"location":"modeling/","text":"Modeling \u00b6 Models \u00b6 To create a Model, simply inherit from the [Model][odmantic.model.Model] class and then specify the field types and eventually their descriptors. Collection \u00b6 Each Model will be linked to its own collection. By default, the collection name will be created from the chosen class name and converted to snake_case . For example a model class named CapitalCity will be stored in the collection named capital_city . If the class name ends with Model , ODMantic will remove it to create the collection name. For example, a model class named PersonModel will belong in the person collection. It's possible to change the collection name of a model by specifying the __collection__ class variable in the class body. Custom collection name example from odmantic import Model class CapitalCity ( Model ): __collection__ = \"city\" name : str population : int Now, when CapitalCity instances will be persisted to the database, they will belong in the city collection instead of capital_city . Warning Models and Embedded models inheritance is not supported yet. Custom model validators \u00b6 Exactly as done with pydantic, it's possible to define custom model validators as described in the pydantic: Root Validators documentation (this apply as well to Embedded Models). In the following example, we will define a rectangle class and add two validators: The first one will check that the height is greater than the width. The second one will ensure that the area of the rectangle is less or equal to 9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from typing import ClassVar from pydantic import ValidationError , root_validator from odmantic import Model class SmallRectangle ( Model ): MAX_AREA : ClassVar [ float ] = 9 length : float width : float @root_validator def check_width_length ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if width > length : raise ValueError ( \"width can't be greater than length\" ) return values @root_validator def check_area ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if length * width > cls . MAX_AREA : raise ValueError ( f \"area is greater than { cls . MAX_AREA } \" ) return values print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 4 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ area is greater than 9 (type=value_error) \"\"\" Tip You can define class variables in the Models using the typing.ClassVar type construct, as done in this example with MAX_AREA . Those class variables will be completely ignored by ODMantic while persisting instances to the database. Embedded Models \u00b6 Using an embedded model will store it directly in the root model it's integrated in. On the MongoDB side, the collection will contain the root documents and in inside each of them, the embedded models will be directly stored. Embedded models are especially useful while building one-to-one or one-to-many relationships. Note Since Embedded Models are directly embedded in the MongoDB collection of the root model, it will not be possible to query on them directly without specifying a root document. The creation of an Embedded model is done by inheriting the [EmbeddedModel][odmantic.model.EmbeddedModel] class. You can then define fields exactly as for the regular Models. One to One \u00b6 In this example, we will model the relation between a country and its capital city. Since one capital city can belong to one and only one country, we can model this relation as a One-to-One relationship. We will use an Embedded Model in this case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity countries = [ Country ( name = \"Switzerland\" , currency = \"Swiss franc\" , capital_city = CapitalCity ( name = \"Bern\" , population = 1035000 ), ), Country ( name = \"Sweden\" , currency = \"Swedish krona\" , capital_city = CapitalCity ( name = \"Stockholm\" , population = 975904 ), ), ] engine = AIOEngine () await engine . save_all ( countries ) Defining this relation is done in the same way as defining a new field. Here, the CapitalCity class will be considered as a field type during the model definition. The [Field][odmantic.field.Field] descriptor can be used as well for Embedded Models in order to bring more flexibility (default values, Mongo key name, ...). Content of the country collection after execution { \"_id\" : ObjectId( \"5f79d7e8b305f24ca43593e2\" ) , \"name\" : \"Sweden\" , \"currency\" : \"Swedish krona\" , \"capital_city\" : { \"name\" : \"Stockholm\" , \"population\" : 975904 } } { \"_id\" : ObjectId( \"5f79d7e8b305f24ca43593e1\" ) , \"name\" : \"Switzerland\" , \"currency\" : \"Swiss franc\" , \"capital_city\" : { \"name\" : \"Bern\" , \"population\" : 1035000 } } Tip It is possible as well to define query filters based on embedded documents content. await engine . find_one ( Country , Country . capital_city . name == \"Stockholm\" ) #> Country( #> id=ObjectId(\"5f79d7e8b305f24ca43593e2\"), #> name=\"Sweden\", #> currency=\"Swedish krona\", #> capital_city=CapitalCity(name=\"Stockholm\", population=975904), #> ) For more details, see the Filtering section. One to Many \u00b6 Here, we will model the relation between a customer of an online shop and his shipping addresses. A single customer can have multiple addresses but these addresses belong only to the customer's account. He should be allowed to modify them without modifying others addresses (for example if two family members use the same address, their addresses should not be linked together). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from typing import List from odmantic import AIOEngine , EmbeddedModel , Model class Address ( EmbeddedModel ): street : str city : str state : str zipcode : str class Customer ( Model ): name : str addresses : List [ Address ] customer = Customer ( name = \"John Doe\" , addresses = [ Address ( street = \"1757 Birch Street\" , city = \"Greenwood\" , state = \"Indiana\" , zipcode = \"46142\" , ), Address ( street = \"262 Barnes Avenue\" , city = \"Cincinnati\" , state = \"Ohio\" , zipcode = \"45216\" , ), ], ) engine = AIOEngine () await engine . save ( customer ) As done previously for the One to One relation, defining a One to Many relationship with Embedded Models is done exactly as defining a field with its type being a sequence of Address objects. Content of the customer collection after execution { \"_id\" : ObjectId( \"5f79eb116371e09b16e4fae4\" ) , \"name\" : \"John Doe\" , \"addresses\" :[ { \"street\" : \"1757 Birch Street\" , \"city\" : \"Greenwood\" , \"state\" : \"Indiana\" , \"zipcode\" : \"46142\" }, { \"street\" : \"262 Barnes Avenue\" , \"city\" : \"Cincinnati\" , \"state\" : \"Ohio\" , \"zipcode\" : \"45216\" } ] } Tip To add conditions on the number of embedded elements, it's possible to use the min_items and max_items arguments of the [Field][odmantic.field.Field] descriptor. Another possibility is to use the typing.Tuple type. Note Building query filters based on the content of a sequence of embedded documents is not supported yet (but this feature is planned for an upcoming release ). Anyway, it's still possible to perform the filtering operation manually using Mongo Array Operators ( $all , $elemMatch , $size ). See the Raw query usage section for more details. Customization \u00b6 Since the Embedded Models are considered as types by ODMantic, most of the complex type constructs that could be imagined should be supported. Some ideas which could be useful: Combine two different embedded models in a single field using typing.Tuple . Allow multiple Embedded model types using a typing.Union type. Make an Embedded model not required using typing.Optional . Embed the documents in a dictionary (using the typing.Dict type) to provide an additional key-value mapping to the embedded documents. Nest embedded documents Referenced models \u00b6 Embedded models are really simple to use but sometimes it is needed as well to have many-to-one (i.e. multiple entities referring to another single one) or many-to-many relationships. This is not really possible to model those using embedded documents and in this case, references will come handy. Another use case where references are useful is for one-to-one/one-to-many relations but when the referenced model has to exist in its own collection, in order to be accessed on its own without any parent model specified. Many to One (Mapped) \u00b6 In this part, we will model the relation between books and publishers. Let's consider that each book has a single publisher. In this case, multiple books could be published by the same publisher. We can thus model this relation as a many-to-one relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from odmantic import AIOEngine , Model , Reference class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference () hachette = Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ) harper = Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ) books = [ Book ( title = \"They Didn't See Us Coming\" , pages = 304 , publisher = hachette ), Book ( title = \"This Isn't Happening\" , pages = 256 , publisher = hachette ), Book ( title = \"Prodigal Summer\" , pages = 464 , publisher = harper ), ] engine = AIOEngine () await engine . save_all ( books ) The definition of a reference field requires the presence of the [Reference()][odmantic.reference.Reference] descriptor. Once the models are defined, linking two instances is done simply by assigning the reference field of referencing instance to the referenced instance. Why is it required to include the Reference descriptor ? The main goal behind enforcing the presence of the descriptor is to have a clear distinction between Embedded Models and References. In the future, a generic Reference[T] type will probably be included to make this distinction since it would make more sense than having to set a descriptor for each reference. Content of the publisher collection after execution { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a365\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } We can see that the publishers have been persisted to their collection even if no explicit save has been perfomed. When calling the [engine.save][odmantic.engine.AIOEngine.save] method, the engine will persist automatically the referenced documents. While fetching instances, the engine will as well resolve every reference. Content of the book collection after execution { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a366\" ) , \"pages\" : 304 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"They Didn't See Us Coming\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a367\" ) , \"pages\" : 256 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"This Isn't Happening\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a368\" ) , \"pages\" : 464 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a365\" ) , \"title\" : \"Prodigal Summer\" } The resulting books in the collection contain the publisher reference directly as a document attribute (using the reference name as the document's key). Tip It's possible to customize the foreign key storage key using the key_name argument while building the [Reference][odmantic.reference.Reference] descriptor. Many to Many (Manual) \u00b6 Here, we will model the relation between books and their authors. Since a book can have multiple authors and an author can be authoring multiple books, we will model this relation as a many-to-many relationship. Note Currently, ODMantic does not support mapped multi-references yet. But we will still define the relationship in a manual way. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import List from bson import ObjectId from odmantic import AIOEngine , Model class Author ( Model ): name : str class Book ( Model ): title : str pages : int author_ids : List [ ObjectId ] david = Author ( name = \"David Beazley\" ) brian = Author ( name = \"Brian K. Jones\" ) python_cookbook = Book ( title = \"Python Cookbook\" , pages = 706 , author_ids = [ david . id , brian . id ] ) python_essentials = Book ( title = \"Python Essential Reference\" , pages = 717 , author_ids = [ brian . id ] ) engine = AIOEngine () await engine . save_all (( david , brian )) await engine . save_all (( python_cookbook , python_essentials )) We defined an author_ids field which holds the list of unique ids of the authors (This id field in the Author model is generated implicitly by default). Since this multi-reference is not mapped by the ODM, we have to persist the authors manually. Content of the author collection after execution { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da4e\" ) , \"name\" : \"David Beazley\" } { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da4f\" ) , \"name\" : \"Brian K. Jones\" } Content of the book collection after execution { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da50\" ) , \"title\" : \"Python Cookbook\" \"pages\" : 706 , \"author_ids\" :[ ObjectId( \"5f7a37dc7311be1362e1da4e\" ) , ObjectId( \"5f7a37dc7311be1362e1da4f\" ) ], } { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da51\" ) , \"title\" : \"Python Essential Reference\" \"pages\" : 717 , \"author_ids\" :[ ObjectId( \"5f7a37dc7311be1362e1da4f\" ) ], } Retrieving the authors of the Python Cookbook First, it's required to fetch the ids of the authors. Then we can use the [in_][odmantic.query.in_] filter to select only the authors with the desired ids. 1 2 3 4 5 6 7 book = await engine . find_one ( Book , Book . title == \"Python Cookbook\" ) authors = await engine . find ( Author , Author . id . in_ ( book . author_ids )) print ( authors ) #> [ #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4e\"), name=\"David Beazley\"), #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4f\"), name=\"Brian K. Jones\"), #> ]","title":"Modeling"},{"location":"modeling/#modeling","text":"","title":"Modeling"},{"location":"modeling/#models","text":"To create a Model, simply inherit from the [Model][odmantic.model.Model] class and then specify the field types and eventually their descriptors.","title":"Models"},{"location":"modeling/#collection","text":"Each Model will be linked to its own collection. By default, the collection name will be created from the chosen class name and converted to snake_case . For example a model class named CapitalCity will be stored in the collection named capital_city . If the class name ends with Model , ODMantic will remove it to create the collection name. For example, a model class named PersonModel will belong in the person collection. It's possible to change the collection name of a model by specifying the __collection__ class variable in the class body. Custom collection name example from odmantic import Model class CapitalCity ( Model ): __collection__ = \"city\" name : str population : int Now, when CapitalCity instances will be persisted to the database, they will belong in the city collection instead of capital_city . Warning Models and Embedded models inheritance is not supported yet.","title":"Collection"},{"location":"modeling/#custom-model-validators","text":"Exactly as done with pydantic, it's possible to define custom model validators as described in the pydantic: Root Validators documentation (this apply as well to Embedded Models). In the following example, we will define a rectangle class and add two validators: The first one will check that the height is greater than the width. The second one will ensure that the area of the rectangle is less or equal to 9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from typing import ClassVar from pydantic import ValidationError , root_validator from odmantic import Model class SmallRectangle ( Model ): MAX_AREA : ClassVar [ float ] = 9 length : float width : float @root_validator def check_width_length ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if width > length : raise ValueError ( \"width can't be greater than length\" ) return values @root_validator def check_area ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if length * width > cls . MAX_AREA : raise ValueError ( f \"area is greater than { cls . MAX_AREA } \" ) return values print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 4 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ area is greater than 9 (type=value_error) \"\"\" Tip You can define class variables in the Models using the typing.ClassVar type construct, as done in this example with MAX_AREA . Those class variables will be completely ignored by ODMantic while persisting instances to the database.","title":"Custom model validators"},{"location":"modeling/#embedded-models","text":"Using an embedded model will store it directly in the root model it's integrated in. On the MongoDB side, the collection will contain the root documents and in inside each of them, the embedded models will be directly stored. Embedded models are especially useful while building one-to-one or one-to-many relationships. Note Since Embedded Models are directly embedded in the MongoDB collection of the root model, it will not be possible to query on them directly without specifying a root document. The creation of an Embedded model is done by inheriting the [EmbeddedModel][odmantic.model.EmbeddedModel] class. You can then define fields exactly as for the regular Models.","title":"Embedded Models"},{"location":"modeling/#one-to-one","text":"In this example, we will model the relation between a country and its capital city. Since one capital city can belong to one and only one country, we can model this relation as a One-to-One relationship. We will use an Embedded Model in this case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity countries = [ Country ( name = \"Switzerland\" , currency = \"Swiss franc\" , capital_city = CapitalCity ( name = \"Bern\" , population = 1035000 ), ), Country ( name = \"Sweden\" , currency = \"Swedish krona\" , capital_city = CapitalCity ( name = \"Stockholm\" , population = 975904 ), ), ] engine = AIOEngine () await engine . save_all ( countries ) Defining this relation is done in the same way as defining a new field. Here, the CapitalCity class will be considered as a field type during the model definition. The [Field][odmantic.field.Field] descriptor can be used as well for Embedded Models in order to bring more flexibility (default values, Mongo key name, ...). Content of the country collection after execution { \"_id\" : ObjectId( \"5f79d7e8b305f24ca43593e2\" ) , \"name\" : \"Sweden\" , \"currency\" : \"Swedish krona\" , \"capital_city\" : { \"name\" : \"Stockholm\" , \"population\" : 975904 } } { \"_id\" : ObjectId( \"5f79d7e8b305f24ca43593e1\" ) , \"name\" : \"Switzerland\" , \"currency\" : \"Swiss franc\" , \"capital_city\" : { \"name\" : \"Bern\" , \"population\" : 1035000 } } Tip It is possible as well to define query filters based on embedded documents content. await engine . find_one ( Country , Country . capital_city . name == \"Stockholm\" ) #> Country( #> id=ObjectId(\"5f79d7e8b305f24ca43593e2\"), #> name=\"Sweden\", #> currency=\"Swedish krona\", #> capital_city=CapitalCity(name=\"Stockholm\", population=975904), #> ) For more details, see the Filtering section.","title":"One to One"},{"location":"modeling/#one-to-many","text":"Here, we will model the relation between a customer of an online shop and his shipping addresses. A single customer can have multiple addresses but these addresses belong only to the customer's account. He should be allowed to modify them without modifying others addresses (for example if two family members use the same address, their addresses should not be linked together). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from typing import List from odmantic import AIOEngine , EmbeddedModel , Model class Address ( EmbeddedModel ): street : str city : str state : str zipcode : str class Customer ( Model ): name : str addresses : List [ Address ] customer = Customer ( name = \"John Doe\" , addresses = [ Address ( street = \"1757 Birch Street\" , city = \"Greenwood\" , state = \"Indiana\" , zipcode = \"46142\" , ), Address ( street = \"262 Barnes Avenue\" , city = \"Cincinnati\" , state = \"Ohio\" , zipcode = \"45216\" , ), ], ) engine = AIOEngine () await engine . save ( customer ) As done previously for the One to One relation, defining a One to Many relationship with Embedded Models is done exactly as defining a field with its type being a sequence of Address objects. Content of the customer collection after execution { \"_id\" : ObjectId( \"5f79eb116371e09b16e4fae4\" ) , \"name\" : \"John Doe\" , \"addresses\" :[ { \"street\" : \"1757 Birch Street\" , \"city\" : \"Greenwood\" , \"state\" : \"Indiana\" , \"zipcode\" : \"46142\" }, { \"street\" : \"262 Barnes Avenue\" , \"city\" : \"Cincinnati\" , \"state\" : \"Ohio\" , \"zipcode\" : \"45216\" } ] } Tip To add conditions on the number of embedded elements, it's possible to use the min_items and max_items arguments of the [Field][odmantic.field.Field] descriptor. Another possibility is to use the typing.Tuple type. Note Building query filters based on the content of a sequence of embedded documents is not supported yet (but this feature is planned for an upcoming release ). Anyway, it's still possible to perform the filtering operation manually using Mongo Array Operators ( $all , $elemMatch , $size ). See the Raw query usage section for more details.","title":"One to Many"},{"location":"modeling/#customization","text":"Since the Embedded Models are considered as types by ODMantic, most of the complex type constructs that could be imagined should be supported. Some ideas which could be useful: Combine two different embedded models in a single field using typing.Tuple . Allow multiple Embedded model types using a typing.Union type. Make an Embedded model not required using typing.Optional . Embed the documents in a dictionary (using the typing.Dict type) to provide an additional key-value mapping to the embedded documents. Nest embedded documents","title":"Customization"},{"location":"modeling/#referenced-models","text":"Embedded models are really simple to use but sometimes it is needed as well to have many-to-one (i.e. multiple entities referring to another single one) or many-to-many relationships. This is not really possible to model those using embedded documents and in this case, references will come handy. Another use case where references are useful is for one-to-one/one-to-many relations but when the referenced model has to exist in its own collection, in order to be accessed on its own without any parent model specified.","title":"Referenced models"},{"location":"modeling/#many-to-one-mapped","text":"In this part, we will model the relation between books and publishers. Let's consider that each book has a single publisher. In this case, multiple books could be published by the same publisher. We can thus model this relation as a many-to-one relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from odmantic import AIOEngine , Model , Reference class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference () hachette = Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ) harper = Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ) books = [ Book ( title = \"They Didn't See Us Coming\" , pages = 304 , publisher = hachette ), Book ( title = \"This Isn't Happening\" , pages = 256 , publisher = hachette ), Book ( title = \"Prodigal Summer\" , pages = 464 , publisher = harper ), ] engine = AIOEngine () await engine . save_all ( books ) The definition of a reference field requires the presence of the [Reference()][odmantic.reference.Reference] descriptor. Once the models are defined, linking two instances is done simply by assigning the reference field of referencing instance to the referenced instance. Why is it required to include the Reference descriptor ? The main goal behind enforcing the presence of the descriptor is to have a clear distinction between Embedded Models and References. In the future, a generic Reference[T] type will probably be included to make this distinction since it would make more sense than having to set a descriptor for each reference. Content of the publisher collection after execution { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a365\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } We can see that the publishers have been persisted to their collection even if no explicit save has been perfomed. When calling the [engine.save][odmantic.engine.AIOEngine.save] method, the engine will persist automatically the referenced documents. While fetching instances, the engine will as well resolve every reference. Content of the book collection after execution { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a366\" ) , \"pages\" : 304 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"They Didn't See Us Coming\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a367\" ) , \"pages\" : 256 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"This Isn't Happening\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a368\" ) , \"pages\" : 464 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a365\" ) , \"title\" : \"Prodigal Summer\" } The resulting books in the collection contain the publisher reference directly as a document attribute (using the reference name as the document's key). Tip It's possible to customize the foreign key storage key using the key_name argument while building the [Reference][odmantic.reference.Reference] descriptor.","title":"Many to One (Mapped)"},{"location":"modeling/#many-to-many-manual","text":"Here, we will model the relation between books and their authors. Since a book can have multiple authors and an author can be authoring multiple books, we will model this relation as a many-to-many relationship. Note Currently, ODMantic does not support mapped multi-references yet. But we will still define the relationship in a manual way. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import List from bson import ObjectId from odmantic import AIOEngine , Model class Author ( Model ): name : str class Book ( Model ): title : str pages : int author_ids : List [ ObjectId ] david = Author ( name = \"David Beazley\" ) brian = Author ( name = \"Brian K. Jones\" ) python_cookbook = Book ( title = \"Python Cookbook\" , pages = 706 , author_ids = [ david . id , brian . id ] ) python_essentials = Book ( title = \"Python Essential Reference\" , pages = 717 , author_ids = [ brian . id ] ) engine = AIOEngine () await engine . save_all (( david , brian )) await engine . save_all (( python_cookbook , python_essentials )) We defined an author_ids field which holds the list of unique ids of the authors (This id field in the Author model is generated implicitly by default). Since this multi-reference is not mapped by the ODM, we have to persist the authors manually. Content of the author collection after execution { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da4e\" ) , \"name\" : \"David Beazley\" } { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da4f\" ) , \"name\" : \"Brian K. Jones\" } Content of the book collection after execution { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da50\" ) , \"title\" : \"Python Cookbook\" \"pages\" : 706 , \"author_ids\" :[ ObjectId( \"5f7a37dc7311be1362e1da4e\" ) , ObjectId( \"5f7a37dc7311be1362e1da4f\" ) ], } { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da51\" ) , \"title\" : \"Python Essential Reference\" \"pages\" : 717 , \"author_ids\" :[ ObjectId( \"5f7a37dc7311be1362e1da4f\" ) ], } Retrieving the authors of the Python Cookbook First, it's required to fetch the ids of the authors. Then we can use the [in_][odmantic.query.in_] filter to select only the authors with the desired ids. 1 2 3 4 5 6 7 book = await engine . find_one ( Book , Book . title == \"Python Cookbook\" ) authors = await engine . find ( Author , Author . id . in_ ( book . author_ids )) print ( authors ) #> [ #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4e\"), name=\"David Beazley\"), #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4f\"), name=\"Brian K. Jones\"), #> ]","title":"Many to Many (Manual)"},{"location":"raw_query_usage/","text":"Raw query usage \u00b6 As ODMantic doesn't completely wrap the MongoDB API, some helpers are provided to be enhance the usability while building raw queries and interacting with raw documents. Raw query helpers \u00b6 Collection name \u00b6 You can get the collection name associated to a model by using the unary + operator on the model class. 1 2 3 4 5 6 7 8 9 10 from odmantic import Model class User ( Model ): name : str collection_name = + User print ( collection_name ) #> user Motor collection \u00b6 The [AIOEngine][odmantic.engine.AIOEngine] object can provide you directly the motor collection ( AsyncIOMotorCollection ) linked to the motor client used by the engine. To achieve this, you can use the [AIOEngine.get_collection][odmantic.engine.AIOEngine.get_collection] method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from odmantic import AIOEngine , Model class User ( Model ): name : str engine = AIOEngine () motor_collection = engine . get_collection ( User ) print ( motor_collection ) #> AsyncIOMotorCollection( #> Collection( #> Database( #> MongoClient( #> host=[\"localhost:27017\"], #> document_class=dict, #> tz_aware=False, #> connect=False, #> driver=DriverInfo(name=\"Motor\", version=\"2.2.0\", platform=\"asyncio\"), #> ), #> \"test\", #> ), #> \"user\", #> ) #> ) Key name of a field \u00b6 Since some field might have some customized key names , you can get the key name associated to a field by using the unary + operator on the model class. As well, to ease the use of aggregation pipelines where you might need to reference your field ( $field ), you can double the operator (i.e use ++ ) to get the field reference name. 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) print ( + User . name ) #> username print ( ++ User . name ) #> $username Creating instances from a raw documents \u00b6 You can parse MongoDB document to instances using the [parse_doc][odmantic.model._BaseODMModel.parse_doc] method. Note If the provided documents contain extra fields, ODMantic will ignore them. This can be especially useful in aggregation pipelines. 1 2 3 4 5 6 7 8 9 10 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) user = User ( name = \"John\" ) print ( user . doc ()) #> {'username': 'John', '_id': ObjectId('5f8352a87a733b8b18b0cb27')} Extract documents from existing instances \u00b6 You can generate a document from instances using the [doc][odmantic.model._BaseODMModel.doc] method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from bson import ObjectId from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) document = { \"username\" : \"John\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( user ) #> id=ObjectId('5f8352a87a733b8b18b0cb27') name='John' Aggregation example \u00b6 In the following example, we will demonstrate the use of the previous helpers to build an aggregation pipeline. We will first consider a Rectangle model with two float fields ( height and length ). We will then fetch the rectangles with an area that is less than 10. To finish, we will reconstruct Rectangle instances from this query. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from odmantic import AIOEngine , Model class Rectangle ( Model ): length : float width : float rectangles = [ Rectangle ( length = 0.1 , width = 1 ), Rectangle ( length = 3.5 , width = 1 ), Rectangle ( length = 2.87 , width = 5.19 ), Rectangle ( length = 1 , width = 10 ), Rectangle ( length = 0.1 , width = 100 ), ] engine = AIOEngine () await engine . save_all ( rectangles ) collection = engine . get_collection ( Rectangle ) pipeline = [] # Add an area field pipeline . append ( { \"$addFields\" : { \"area\" : { \"$multiply\" : [ ++ Rectangle . length , ++ Rectangle . width ] } # Compute the area remotely } } ) # Filter only rectanges with an area lower than 10 pipeline . append ({ \"$match\" : { \"area\" : { \"$lt\" : 10 }}}) # Project to keep only the defined fields (this step is optional) pipeline . append ( { \"$project\" : { + Rectangle . length : True , + Rectangle . width : True , } # Specifying \"area\": False is unnecessary here } ) documents = await collection . aggregate ( pipeline ) . to_list ( length = None ) small_rectangles = [ Rectangle . parse_doc ( doc ) for doc in documents ] print ( small_rectangles ) #> [ #> Rectangle(id=ObjectId(\"...\"), length=0.1, width=1.0), #> Rectangle(id=ObjectId(\"...\"), length=3.5, width=1.0), #> ]","title":"Raw query usage"},{"location":"raw_query_usage/#raw-query-usage","text":"As ODMantic doesn't completely wrap the MongoDB API, some helpers are provided to be enhance the usability while building raw queries and interacting with raw documents.","title":"Raw query usage"},{"location":"raw_query_usage/#raw-query-helpers","text":"","title":"Raw query helpers"},{"location":"raw_query_usage/#collection-name","text":"You can get the collection name associated to a model by using the unary + operator on the model class. 1 2 3 4 5 6 7 8 9 10 from odmantic import Model class User ( Model ): name : str collection_name = + User print ( collection_name ) #> user","title":"Collection name"},{"location":"raw_query_usage/#motor-collection","text":"The [AIOEngine][odmantic.engine.AIOEngine] object can provide you directly the motor collection ( AsyncIOMotorCollection ) linked to the motor client used by the engine. To achieve this, you can use the [AIOEngine.get_collection][odmantic.engine.AIOEngine.get_collection] method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from odmantic import AIOEngine , Model class User ( Model ): name : str engine = AIOEngine () motor_collection = engine . get_collection ( User ) print ( motor_collection ) #> AsyncIOMotorCollection( #> Collection( #> Database( #> MongoClient( #> host=[\"localhost:27017\"], #> document_class=dict, #> tz_aware=False, #> connect=False, #> driver=DriverInfo(name=\"Motor\", version=\"2.2.0\", platform=\"asyncio\"), #> ), #> \"test\", #> ), #> \"user\", #> ) #> )","title":"Motor collection"},{"location":"raw_query_usage/#key-name-of-a-field","text":"Since some field might have some customized key names , you can get the key name associated to a field by using the unary + operator on the model class. As well, to ease the use of aggregation pipelines where you might need to reference your field ( $field ), you can double the operator (i.e use ++ ) to get the field reference name. 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) print ( + User . name ) #> username print ( ++ User . name ) #> $username","title":"Key name of a field"},{"location":"raw_query_usage/#creating-instances-from-a-raw-documents","text":"You can parse MongoDB document to instances using the [parse_doc][odmantic.model._BaseODMModel.parse_doc] method. Note If the provided documents contain extra fields, ODMantic will ignore them. This can be especially useful in aggregation pipelines. 1 2 3 4 5 6 7 8 9 10 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) user = User ( name = \"John\" ) print ( user . doc ()) #> {'username': 'John', '_id': ObjectId('5f8352a87a733b8b18b0cb27')}","title":"Creating instances from a raw documents"},{"location":"raw_query_usage/#extract-documents-from-existing-instances","text":"You can generate a document from instances using the [doc][odmantic.model._BaseODMModel.doc] method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from bson import ObjectId from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) document = { \"username\" : \"John\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( user ) #> id=ObjectId('5f8352a87a733b8b18b0cb27') name='John'","title":"Extract documents from existing instances"},{"location":"raw_query_usage/#aggregation-example","text":"In the following example, we will demonstrate the use of the previous helpers to build an aggregation pipeline. We will first consider a Rectangle model with two float fields ( height and length ). We will then fetch the rectangles with an area that is less than 10. To finish, we will reconstruct Rectangle instances from this query. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from odmantic import AIOEngine , Model class Rectangle ( Model ): length : float width : float rectangles = [ Rectangle ( length = 0.1 , width = 1 ), Rectangle ( length = 3.5 , width = 1 ), Rectangle ( length = 2.87 , width = 5.19 ), Rectangle ( length = 1 , width = 10 ), Rectangle ( length = 0.1 , width = 100 ), ] engine = AIOEngine () await engine . save_all ( rectangles ) collection = engine . get_collection ( Rectangle ) pipeline = [] # Add an area field pipeline . append ( { \"$addFields\" : { \"area\" : { \"$multiply\" : [ ++ Rectangle . length , ++ Rectangle . width ] } # Compute the area remotely } } ) # Filter only rectanges with an area lower than 10 pipeline . append ({ \"$match\" : { \"area\" : { \"$lt\" : 10 }}}) # Project to keep only the defined fields (this step is optional) pipeline . append ( { \"$project\" : { + Rectangle . length : True , + Rectangle . width : True , } # Specifying \"area\": False is unnecessary here } ) documents = await collection . aggregate ( pipeline ) . to_list ( length = None ) small_rectangles = [ Rectangle . parse_doc ( doc ) for doc in documents ] print ( small_rectangles ) #> [ #> Rectangle(id=ObjectId(\"...\"), length=0.1, width=1.0), #> Rectangle(id=ObjectId(\"...\"), length=3.5, width=1.0), #> ]","title":"Aggregation example"},{"location":"usage_fastapi/","text":"Usage with FastAPI \u00b6 ODMantic model as a response \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import List import uvicorn from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId from odmantic.fastapi import AIOEngineDependency class TreeModel ( Model ): \"\"\"My Tree Model\"\"\" name : str average_size : float discovery_year : int app = FastAPI () EngineD = AIOEngineDependency () @app . post ( \"/trees/\" , response_model = TreeModel ) async def create_tree ( tree : TreeModel , engine : AIOEngine = EngineD ): await engine . save ( tree ) return tree @app . get ( \"/trees/\" , response_model = List [ TreeModel ]) async def get_trees ( engine : AIOEngine = EngineD ): trees = await engine . find ( TreeModel ) return trees @app . get ( \"/trees/ {id} \" , response_model = TreeModel ) async def get_tree_by_id ( id : ObjectId , engine : AIOEngine = EngineD ): tree = await engine . find_one ( TreeModel , TreeModel . id == id ) if tree is None : raise HTTPException ( 404 ) return tree if __name__ == \"__main__\" : uvicorn . run ( app , host = \"localhost\" , port = 8080 )","title":"Usage with FastAPI"},{"location":"usage_fastapi/#usage-with-fastapi","text":"","title":"Usage with FastAPI"},{"location":"usage_fastapi/#odmantic-model-as-a-response","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import List import uvicorn from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId from odmantic.fastapi import AIOEngineDependency class TreeModel ( Model ): \"\"\"My Tree Model\"\"\" name : str average_size : float discovery_year : int app = FastAPI () EngineD = AIOEngineDependency () @app . post ( \"/trees/\" , response_model = TreeModel ) async def create_tree ( tree : TreeModel , engine : AIOEngine = EngineD ): await engine . save ( tree ) return tree @app . get ( \"/trees/\" , response_model = List [ TreeModel ]) async def get_trees ( engine : AIOEngine = EngineD ): trees = await engine . find ( TreeModel ) return trees @app . get ( \"/trees/ {id} \" , response_model = TreeModel ) async def get_tree_by_id ( id : ObjectId , engine : AIOEngine = EngineD ): tree = await engine . find_one ( TreeModel , TreeModel . id == id ) if tree is None : raise HTTPException ( 404 ) return tree if __name__ == \"__main__\" : uvicorn . run ( app , host = \"localhost\" , port = 8080 )","title":"ODMantic model as a response"},{"location":"usage_pydantic/","text":"Usage with Pydantic \u00b6 Defining models with BSON Fields \u00b6","title":"Usage with Pydantic"},{"location":"usage_pydantic/#usage-with-pydantic","text":"","title":"Usage with Pydantic"},{"location":"usage_pydantic/#defining-models-with-bson-fields","text":"","title":"Defining models with BSON Fields"},{"location":"api_reference/bson/","text":"This module provides helpers to build Pydantic Models containing BSON objects. Pydantic model helpers \u00b6 odmantic.bson.BSON_TYPES_ENCODERS \u00b6 Encoders required to encode BSON fields (can be used in the Pydantic Model's Config.json_encoders parameter). See pydantic: JSON Encoders for more details. Pydantic type helpers \u00b6 Those helpers inherit directly from their respective bson types. They add the field validation logic required by Pydantic to work with them. odmantic.bson.ObjectId \u00b6 odmantic.bson.Int64 \u00b6 odmantic.bson.Decimal128 \u00b6 odmantic.bson.Binary \u00b6 odmantic.bson.Regex \u00b6","title":"odmantic.bson"},{"location":"api_reference/bson/#pydantic-model-helpers","text":"","title":"Pydantic model helpers"},{"location":"api_reference/bson/#odmantic.bson.BSON_TYPES_ENCODERS","text":"Encoders required to encode BSON fields (can be used in the Pydantic Model's Config.json_encoders parameter). See pydantic: JSON Encoders for more details.","title":"BSON_TYPES_ENCODERS"},{"location":"api_reference/bson/#pydantic-type-helpers","text":"Those helpers inherit directly from their respective bson types. They add the field validation logic required by Pydantic to work with them.","title":"Pydantic type helpers"},{"location":"api_reference/bson/#odmantic.bson.ObjectId","text":"","title":"ObjectId"},{"location":"api_reference/bson/#odmantic.bson.Int64","text":"","title":"Int64"},{"location":"api_reference/bson/#odmantic.bson.Decimal128","text":"","title":"Decimal128"},{"location":"api_reference/bson/#odmantic.bson.Binary","text":"","title":"Binary"},{"location":"api_reference/bson/#odmantic.bson.Regex","text":"","title":"Regex"},{"location":"api_reference/engine/","text":"odmantic.engine.AIOEngine \u00b6 The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. __init__ ( self , motor_client = None , database = 'test' ) special \u00b6 Engine constructor. Parameters: Name Type Description Default motor_client AsyncIOMotorClient instance of an AsyncIO motor client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\"Engine constructor. Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 ValueError --> \"\"\" # https://docs.mongodb.com/manual/reference/limits/#naming-restrictions forbidden_characters = _FORBIDDEN_DATABASE_CHARACTERS . intersection ( set ( database ) ) if len ( forbidden_characters ) > 0 : raise ValueError ( f \"database name cannot contain: { ' ' . join ( forbidden_characters ) } \" ) if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database_name = database self . database = motor_client [ self . database_name ] count ( self , model , * queries ) async \u00b6 Get the count of documents matching a query Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filters to apply () Returns: Type Description int number of document matching the query Source code in odmantic/engine.py async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ] ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on queries: query filters to apply Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = AIOEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count ) delete ( self , instance ) async \u00b6 Delete an instance from the database Parameters: Name Type Description Default instance ~ModelType the instance to delete required Exceptions: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance ) find ( self , model , * queries , * , limit = None , skip = 0 ) \u00b6 Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply () limit Optional[int] maximum number of instance fetched None skip int number of document to skip 0 Returns: Type Description odmantic.engine.AIOCursor[~ModelType] [odmantic.engine.AIOCursor][] of the query Source code in odmantic/engine.py def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy limit : Optional [ int ] = None , skip : int = 0 , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on queries: query filter to apply limit: maximum number of instance fetched skip: number of document to skip Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor ) find_one ( self , model , * queries ) async \u00b6 Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply () Returns: Type Description Optional[~ModelType] the fetched instance if found otherwise None Source code in odmantic/engine.py async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin, ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on queries: query filter to apply Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ] get_collection ( self , model ) \u00b6 Get the motor collection associated to a Model. Parameters: Name Type Description Default model Type[~ModelType] model class required Returns: Type Description AsyncIOMotorCollection the AsyncIO motor collection object Source code in odmantic/engine.py def get_collection ( self , model : Type [ ModelType ]) -> AsyncIOMotorCollection : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ] save ( self , instance ) async \u00b6 Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ~ModelType instance to persist required Returns: Type Description ~ModelType the saved instance Note The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py async def save ( self , instance : ModelType ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance save_all ( self , instances ) async \u00b6 Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence[~ModelType] instances to persist required Returns: Type Description List[~ModelType] the saved instances Note The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances odmantic.engine.AIOCursor \u00b6 This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models","title":"odmantic.engine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine","text":"The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor.","title":"AIOEngine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.__init__","text":"Engine constructor. Parameters: Name Type Description Default motor_client AsyncIOMotorClient instance of an AsyncIO motor client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\"Engine constructor. Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 ValueError --> \"\"\" # https://docs.mongodb.com/manual/reference/limits/#naming-restrictions forbidden_characters = _FORBIDDEN_DATABASE_CHARACTERS . intersection ( set ( database ) ) if len ( forbidden_characters ) > 0 : raise ValueError ( f \"database name cannot contain: { ' ' . join ( forbidden_characters ) } \" ) if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database_name = database self . database = motor_client [ self . database_name ]","title":"__init__()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.count","text":"Get the count of documents matching a query Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filters to apply () Returns: Type Description int number of document matching the query Source code in odmantic/engine.py async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ] ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on queries: query filters to apply Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = AIOEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count )","title":"count()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.delete","text":"Delete an instance from the database Parameters: Name Type Description Default instance ~ModelType the instance to delete required Exceptions: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance )","title":"delete()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find","text":"Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply () limit Optional[int] maximum number of instance fetched None skip int number of document to skip 0 Returns: Type Description odmantic.engine.AIOCursor[~ModelType] [odmantic.engine.AIOCursor][] of the query Source code in odmantic/engine.py def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy limit : Optional [ int ] = None , skip : int = 0 , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on queries: query filter to apply limit: maximum number of instance fetched skip: number of document to skip Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor )","title":"find()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find_one","text":"Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply () Returns: Type Description Optional[~ModelType] the fetched instance if found otherwise None Source code in odmantic/engine.py async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin, ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on queries: query filter to apply Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ]","title":"find_one()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.get_collection","text":"Get the motor collection associated to a Model. Parameters: Name Type Description Default model Type[~ModelType] model class required Returns: Type Description AsyncIOMotorCollection the AsyncIO motor collection object Source code in odmantic/engine.py def get_collection ( self , model : Type [ ModelType ]) -> AsyncIOMotorCollection : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ]","title":"get_collection()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save","text":"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ~ModelType instance to persist required Returns: Type Description ~ModelType the saved instance Note The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py async def save ( self , instance : ModelType ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance","title":"save()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save_all","text":"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence[~ModelType] instances to persist required Returns: Type Description List[~ModelType] the saved instances Note The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances","title":"save_all()"},{"location":"api_reference/engine/#odmantic.engine.AIOCursor","text":"This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models","title":"AIOCursor"},{"location":"api_reference/exceptions/","text":"odmantic.exceptions.BaseEngineException \u00b6 Base Exception raised by the engine while operating on a model. odmantic.exceptions.DocumentNotFoundError \u00b6 The targetted document has not been found by the engine. Attributes: Name Type Description instance Model the instance that has not been found","title":"odmantic.exceptions"},{"location":"api_reference/exceptions/#odmantic.exceptions.BaseEngineException","text":"Base Exception raised by the engine while operating on a model.","title":"BaseEngineException"},{"location":"api_reference/exceptions/#odmantic.exceptions.DocumentNotFoundError","text":"The targetted document has not been found by the engine. Attributes: Name Type Description instance Model the instance that has not been found","title":"DocumentNotFoundError"},{"location":"api_reference/fastapi/","text":"odmantic.fastapi.AIOEngineDependency \u00b6","title":"odmantic.fastapi"},{"location":"api_reference/fastapi/#odmantic.fastapi.AIOEngineDependency","text":"","title":"AIOEngineDependency"},{"location":"api_reference/field/","text":"odmantic.field.Field ( default = PydanticUndefined , * , key_name = None , primary_field = False , default_factory = None , title = None , description = None , const = None , gt = None , ge = None , lt = None , le = None , multiple_of = None , min_items = None , max_items = None , min_length = None , max_length = None , regex = None , ** extra ) \u00b6 Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields ( int , float , Decimal ) and some apply only to str . Tip The main additions of ODMantic to the regular pydantic Field are the key_name and the primary_field options. Warning If both default and default_factory are set, an error is raised. Warning primary_field can't be used along with key_name since the key_name will be set to _id . Parameters: Name Type Description Default default Any since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis ( ... ) to indicate the field has no default value PydanticUndefined key_name Optional[str] the name to use in the the mongo document structure None primary_field bool this field should be considered as a primary key. False default_factory Optional[Callable[[], Any]] callable that will be called when a default value is needed for this field. None title Optional[str] can be any string, used in the schema None description Optional[str] can be any string, used in the schema None const Optional[bool] this field is required and must take it's default value None gt Optional[float] only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword None ge Optional[float] only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword None lt Optional[float] only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword None le Optional[float] only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a maximum validation keyword None multiple_of Optional[float] only applies to numbers, requires the field to be \"a multiple of \". The schema will have a multipleOf validation keyword None min_items Optional[int] only applies to sequences, requires the field to have a minimum item count. None max_items Optional[int] only applies to sequences, requires the field to have a maximum item count. None min_length Optional[int] only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword None max_length Optional[int] only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword None regex Optional[str] only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a pattern validation keyword None **extra Any any additional keyword arguments will be added as is to the schema {} Source code in odmantic/field.py def Field ( default : Any = Undefined , * , key_name : Optional [ str ] = None , primary_field : bool = False , default_factory : Optional [ NoArgAnyCallable ] = None , # alias: str = None, # FIXME not supported yet title : Optional [ str ] = None , description : Optional [ str ] = None , const : Optional [ bool ] = None , gt : Optional [ float ] = None , ge : Optional [ float ] = None , lt : Optional [ float ] = None , le : Optional [ float ] = None , multiple_of : Optional [ float ] = None , min_items : Optional [ int ] = None , max_items : Optional [ int ] = None , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , regex : Optional [ str ] = None , ** extra : Any , ) -> Any : \"\"\"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. Tip: The main additions of ODMantic to the regular pydantic `Field` are the `key_name` and the `primary_field` options. Warning: If both `default` and `default_factory` are set, an error is raised. Warning: `primary_field` can't be used along with `key_name` since the key_name will be set to `_id`. Args: default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field has no default value key_name: the name to use in the the mongo document structure primary_field: this field should be considered as a primary key. default_factory: callable that will be called when a default value is needed for this field. title: can be any string, used in the schema description: can be any string, used in the schema const: this field is required and *must* take it's default value gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an ``exclusiveMinimum`` validation keyword ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a ``minimum`` validation keyword lt: only applies to numbers, requires the field to be \"less than\". The schema will have an ``exclusiveMaximum`` validation keyword le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a ``maximum`` validation keyword multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a ``multipleOf`` validation keyword min_items: only applies to sequences, requires the field to have a minimum item count. max_items: only applies to sequences, requires the field to have a maximum item count. min_length: only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword max_length: only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a ``pattern`` validation keyword **extra: any additional keyword arguments will be added as is to the schema <!--- # noqa: DAR201 # noqa: DAR003 # noqa: DAR401 # noqa: DAR101 --> \"\"\" # Perform casts on optional fields to avoid incompatibility due to the strict # optional mypy setting pydantic_field = PDField ( default , default_factory = default_factory , # alias=alias, # FIXME check aliases compatibility title = cast ( str , title ), description = cast ( str , description ), const = cast ( bool , const ), gt = cast ( float , gt ), ge = cast ( float , ge ), lt = cast ( float , lt ), le = cast ( float , le ), multiple_of = cast ( float , multiple_of ), min_items = cast ( int , min_items ), max_items = cast ( int , max_items ), min_length = cast ( int , min_length ), max_length = cast ( int , max_length ), regex = cast ( str , regex ), ** extra , ) if primary_field : if key_name is not None and key_name != \"_id\" : raise ValueError ( \"cannot specify a primary field with a custom key_name,\" \"key_name='_id' enforced\" ) else : key_name = \"_id\" elif key_name == \"_id\" : raise ValueError ( \"cannot specify key_name='_id' without defining the field as primary\" ) return ODMFieldInfo ( pydantic_field_info = pydantic_field , primary_field = primary_field , key_name = key_name , )","title":"odmantic.field"},{"location":"api_reference/field/#odmantic.field.Field","text":"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields ( int , float , Decimal ) and some apply only to str . Tip The main additions of ODMantic to the regular pydantic Field are the key_name and the primary_field options. Warning If both default and default_factory are set, an error is raised. Warning primary_field can't be used along with key_name since the key_name will be set to _id . Parameters: Name Type Description Default default Any since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis ( ... ) to indicate the field has no default value PydanticUndefined key_name Optional[str] the name to use in the the mongo document structure None primary_field bool this field should be considered as a primary key. False default_factory Optional[Callable[[], Any]] callable that will be called when a default value is needed for this field. None title Optional[str] can be any string, used in the schema None description Optional[str] can be any string, used in the schema None const Optional[bool] this field is required and must take it's default value None gt Optional[float] only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword None ge Optional[float] only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword None lt Optional[float] only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword None le Optional[float] only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a maximum validation keyword None multiple_of Optional[float] only applies to numbers, requires the field to be \"a multiple of \". The schema will have a multipleOf validation keyword None min_items Optional[int] only applies to sequences, requires the field to have a minimum item count. None max_items Optional[int] only applies to sequences, requires the field to have a maximum item count. None min_length Optional[int] only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword None max_length Optional[int] only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword None regex Optional[str] only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a pattern validation keyword None **extra Any any additional keyword arguments will be added as is to the schema {} Source code in odmantic/field.py def Field ( default : Any = Undefined , * , key_name : Optional [ str ] = None , primary_field : bool = False , default_factory : Optional [ NoArgAnyCallable ] = None , # alias: str = None, # FIXME not supported yet title : Optional [ str ] = None , description : Optional [ str ] = None , const : Optional [ bool ] = None , gt : Optional [ float ] = None , ge : Optional [ float ] = None , lt : Optional [ float ] = None , le : Optional [ float ] = None , multiple_of : Optional [ float ] = None , min_items : Optional [ int ] = None , max_items : Optional [ int ] = None , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , regex : Optional [ str ] = None , ** extra : Any , ) -> Any : \"\"\"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. Tip: The main additions of ODMantic to the regular pydantic `Field` are the `key_name` and the `primary_field` options. Warning: If both `default` and `default_factory` are set, an error is raised. Warning: `primary_field` can't be used along with `key_name` since the key_name will be set to `_id`. Args: default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field has no default value key_name: the name to use in the the mongo document structure primary_field: this field should be considered as a primary key. default_factory: callable that will be called when a default value is needed for this field. title: can be any string, used in the schema description: can be any string, used in the schema const: this field is required and *must* take it's default value gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an ``exclusiveMinimum`` validation keyword ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a ``minimum`` validation keyword lt: only applies to numbers, requires the field to be \"less than\". The schema will have an ``exclusiveMaximum`` validation keyword le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a ``maximum`` validation keyword multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a ``multipleOf`` validation keyword min_items: only applies to sequences, requires the field to have a minimum item count. max_items: only applies to sequences, requires the field to have a maximum item count. min_length: only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword max_length: only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a ``pattern`` validation keyword **extra: any additional keyword arguments will be added as is to the schema <!--- # noqa: DAR201 # noqa: DAR003 # noqa: DAR401 # noqa: DAR101 --> \"\"\" # Perform casts on optional fields to avoid incompatibility due to the strict # optional mypy setting pydantic_field = PDField ( default , default_factory = default_factory , # alias=alias, # FIXME check aliases compatibility title = cast ( str , title ), description = cast ( str , description ), const = cast ( bool , const ), gt = cast ( float , gt ), ge = cast ( float , ge ), lt = cast ( float , lt ), le = cast ( float , le ), multiple_of = cast ( float , multiple_of ), min_items = cast ( int , min_items ), max_items = cast ( int , max_items ), min_length = cast ( int , min_length ), max_length = cast ( int , max_length ), regex = cast ( str , regex ), ** extra , ) if primary_field : if key_name is not None and key_name != \"_id\" : raise ValueError ( \"cannot specify a primary field with a custom key_name,\" \"key_name='_id' enforced\" ) else : key_name = \"_id\" elif key_name == \"_id\" : raise ValueError ( \"cannot specify key_name='_id' without defining the field as primary\" ) return ODMFieldInfo ( pydantic_field_info = pydantic_field , primary_field = primary_field , key_name = key_name , )","title":"Field()"},{"location":"api_reference/model/","text":"odmantic.model._BaseODMModel private \u00b6 Base class for [Model][odmantic.model.Model] and [EmbeddedModel][odmantic.model.EmbeddedModel]. Warning This internal class should never be instanciated directly. doc ( self , include = None ) \u00b6 Generate a document representation of the instance (as a dictionary). Parameters: Name Type Description Default include Optional[AbstractSetIntStr] field that should be included; if None, all the field will be included None Returns: Type Description Dict[str, Any] the document associated to the instance Source code in odmantic/model.py def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, all the field will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc : Dict [ str , Any ] = {} for field_name , field in self . __odm_fields__ . items (): if include is not None and field_name not in include : continue if isinstance ( field , ODMReference ): doc [ field . key_name ] = raw_doc [ field_name ][ \"id\" ] else : if field_name in self . __bson_serialized_fields__ : doc [ field . key_name ] = self . __fields__ [ field_name ] . type_ . __bson__ ( raw_doc [ field_name ] ) else : doc [ field . key_name ] = raw_doc [ field_name ] return doc parse_doc ( raw_doc ) classmethod \u00b6 Parse a BSON document into an instance of the Model Parameters: Name Type Description Default raw_doc Dict document to parse (as Dict) required Returns: Type Description ~TBase an instance of the Model class this method is called on. Source code in odmantic/model.py @classmethod def parse_doc ( cls : Type [ TBase ], raw_doc : Dict ) -> TBase : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Returns: an instance of the Model class this method is called on. \"\"\" doc : Dict [ str , Any ] = {} for field_name , field in cls . __odm_fields__ . items (): if isinstance ( field , ODMReference ): doc [ field_name ] = field . model . parse_doc ( raw_doc [ field . key_name ]) else : doc [ field_name ] = raw_doc [ field . key_name ] instance = cls . parse_obj ( doc ) return instance odmantic.model.Model \u00b6 Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the __collection__ class variable in the model classes. odmantic.model.EmbeddedModel \u00b6 Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model.","title":"odmantic.model"},{"location":"api_reference/model/#odmantic.model._BaseODMModel","text":"Base class for [Model][odmantic.model.Model] and [EmbeddedModel][odmantic.model.EmbeddedModel]. Warning This internal class should never be instanciated directly.","title":"_BaseODMModel"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.doc","text":"Generate a document representation of the instance (as a dictionary). Parameters: Name Type Description Default include Optional[AbstractSetIntStr] field that should be included; if None, all the field will be included None Returns: Type Description Dict[str, Any] the document associated to the instance Source code in odmantic/model.py def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, all the field will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc : Dict [ str , Any ] = {} for field_name , field in self . __odm_fields__ . items (): if include is not None and field_name not in include : continue if isinstance ( field , ODMReference ): doc [ field . key_name ] = raw_doc [ field_name ][ \"id\" ] else : if field_name in self . __bson_serialized_fields__ : doc [ field . key_name ] = self . __fields__ [ field_name ] . type_ . __bson__ ( raw_doc [ field_name ] ) else : doc [ field . key_name ] = raw_doc [ field_name ] return doc","title":"doc()"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.parse_doc","text":"Parse a BSON document into an instance of the Model Parameters: Name Type Description Default raw_doc Dict document to parse (as Dict) required Returns: Type Description ~TBase an instance of the Model class this method is called on. Source code in odmantic/model.py @classmethod def parse_doc ( cls : Type [ TBase ], raw_doc : Dict ) -> TBase : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Returns: an instance of the Model class this method is called on. \"\"\" doc : Dict [ str , Any ] = {} for field_name , field in cls . __odm_fields__ . items (): if isinstance ( field , ODMReference ): doc [ field_name ] = field . model . parse_doc ( raw_doc [ field . key_name ]) else : doc [ field_name ] = raw_doc [ field . key_name ] instance = cls . parse_obj ( doc ) return instance","title":"parse_doc()"},{"location":"api_reference/model/#odmantic.model.Model","text":"Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the __collection__ class variable in the model classes.","title":"Model"},{"location":"api_reference/model/#odmantic.model.EmbeddedModel","text":"Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model.","title":"EmbeddedModel"},{"location":"api_reference/query/","text":"odmantic.query.QueryExpression \u00b6 Base object used to build queries. All comparison and logical operators returns QueryExpression objects. The | and & operators are supported for respectively the [or][odmantic.query.or_] and the [and][odmantic.query.and_] logical operators. Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Logical Operators \u00b6 odmantic.query.and_ ( * elements ) \u00b6 Logical AND operation between multiple QueryExpression objects. Source code in odmantic/query.py def and_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **AND** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$and\" : elements }) odmantic.query.or_ ( * elements ) \u00b6 Logical OR operation between multiple QueryExpression objects. Source code in odmantic/query.py def or_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **OR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$or\" : elements }) odmantic.query.nor_ ( * elements ) \u00b6 Logical NOR operation between multiple QueryExpression objects. Source code in odmantic/query.py def nor_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **NOR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$nor\" : elements }) Comparison Operators \u00b6 odmantic.query.eq ( field , value ) \u00b6 Equality comparison operator. Source code in odmantic/query.py def eq ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Equality comparison operator.\"\"\" return _cmp_expression ( field , \"$eq\" , value ) odmantic.query.ne ( field , value ) \u00b6 Inequality comparison operator (includes documents not containing the field). Source code in odmantic/query.py def ne ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Inequality comparison operator (includes documents not containing the field).\"\"\" return _cmp_expression ( field , \"$ne\" , value ) odmantic.query.gt ( field , value ) \u00b6 Greater than (strict) comparison operator (i.e. >). Source code in odmantic/query.py def gt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than (strict) comparison operator (i.e. >).\"\"\" return _cmp_expression ( field , \"$gt\" , value ) odmantic.query.gte ( field , value ) \u00b6 Greater than or equal comparison operator (i.e. >=). Source code in odmantic/query.py def gte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than or equal comparison operator (i.e. >=).\"\"\" return _cmp_expression ( field , \"$gte\" , value ) odmantic.query.lt ( field , value ) \u00b6 Less than (strict) comparison operator (i.e. <). Source code in odmantic/query.py def lt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than (strict) comparison operator (i.e. <).\"\"\" return _cmp_expression ( field , \"$lt\" , value ) odmantic.query.lte ( field , value ) \u00b6 Less than or equal comparison operator (i.e. <=). Source code in odmantic/query.py def lte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than or equal comparison operator (i.e. <=).\"\"\" return _cmp_expression ( field , \"$lte\" , value ) odmantic.query.in_ ( field , sequence ) \u00b6 Select instances where field is contained in sequence . Source code in odmantic/query.py def in_ ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$in\" , sequence ) odmantic.query.not_in ( field , sequence ) \u00b6 Select instances where field is not contained in sequence . Source code in odmantic/query.py def not_in ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is **not** contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$nin\" , sequence ) odmantic.query.match ( field , pattern ) \u00b6 Select instances where field matches the pattern regular expression. Source code in odmantic/query.py def match ( field : FieldProxyAny , pattern : Union [ Pattern , str ]) -> QueryExpression : \"\"\"Select instances where `field` matches the `pattern` regular expression.\"\"\" # FIXME might create incompatibilities # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not if isinstance ( pattern , str ): r = re . compile ( pattern ) else : r = pattern return QueryExpression ({ + field : r })","title":"odmantic.query"},{"location":"api_reference/query/#odmantic.query.QueryExpression","text":"Base object used to build queries. All comparison and logical operators returns QueryExpression objects. The | and & operators are supported for respectively the [or][odmantic.query.or_] and the [and][odmantic.query.and_] logical operators. Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues.","title":"QueryExpression"},{"location":"api_reference/query/#logical-operators","text":"","title":"Logical Operators"},{"location":"api_reference/query/#odmantic.query.and_","text":"Logical AND operation between multiple QueryExpression objects. Source code in odmantic/query.py def and_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **AND** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$and\" : elements })","title":"and_()"},{"location":"api_reference/query/#odmantic.query.or_","text":"Logical OR operation between multiple QueryExpression objects. Source code in odmantic/query.py def or_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **OR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$or\" : elements })","title":"or_()"},{"location":"api_reference/query/#odmantic.query.nor_","text":"Logical NOR operation between multiple QueryExpression objects. Source code in odmantic/query.py def nor_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **NOR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$nor\" : elements })","title":"nor_()"},{"location":"api_reference/query/#comparison-operators","text":"","title":"Comparison Operators"},{"location":"api_reference/query/#odmantic.query.eq","text":"Equality comparison operator. Source code in odmantic/query.py def eq ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Equality comparison operator.\"\"\" return _cmp_expression ( field , \"$eq\" , value )","title":"eq()"},{"location":"api_reference/query/#odmantic.query.ne","text":"Inequality comparison operator (includes documents not containing the field). Source code in odmantic/query.py def ne ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Inequality comparison operator (includes documents not containing the field).\"\"\" return _cmp_expression ( field , \"$ne\" , value )","title":"ne()"},{"location":"api_reference/query/#odmantic.query.gt","text":"Greater than (strict) comparison operator (i.e. >). Source code in odmantic/query.py def gt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than (strict) comparison operator (i.e. >).\"\"\" return _cmp_expression ( field , \"$gt\" , value )","title":"gt()"},{"location":"api_reference/query/#odmantic.query.gte","text":"Greater than or equal comparison operator (i.e. >=). Source code in odmantic/query.py def gte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than or equal comparison operator (i.e. >=).\"\"\" return _cmp_expression ( field , \"$gte\" , value )","title":"gte()"},{"location":"api_reference/query/#odmantic.query.lt","text":"Less than (strict) comparison operator (i.e. <). Source code in odmantic/query.py def lt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than (strict) comparison operator (i.e. <).\"\"\" return _cmp_expression ( field , \"$lt\" , value )","title":"lt()"},{"location":"api_reference/query/#odmantic.query.lte","text":"Less than or equal comparison operator (i.e. <=). Source code in odmantic/query.py def lte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than or equal comparison operator (i.e. <=).\"\"\" return _cmp_expression ( field , \"$lte\" , value )","title":"lte()"},{"location":"api_reference/query/#odmantic.query.in_","text":"Select instances where field is contained in sequence . Source code in odmantic/query.py def in_ ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$in\" , sequence )","title":"in_()"},{"location":"api_reference/query/#odmantic.query.not_in","text":"Select instances where field is not contained in sequence . Source code in odmantic/query.py def not_in ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is **not** contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$nin\" , sequence )","title":"not_in()"},{"location":"api_reference/query/#odmantic.query.match","text":"Select instances where field matches the pattern regular expression. Source code in odmantic/query.py def match ( field : FieldProxyAny , pattern : Union [ Pattern , str ]) -> QueryExpression : \"\"\"Select instances where `field` matches the `pattern` regular expression.\"\"\" # FIXME might create incompatibilities # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not if isinstance ( pattern , str ): r = re . compile ( pattern ) else : r = pattern return QueryExpression ({ + field : r })","title":"match()"},{"location":"api_reference/reference/","text":"odmantic.reference.Reference ( * , key_name = None ) \u00b6 Used to define reference fields. Parameters: Name Type Description Default key_name Optional[str] name of the Mongo key that stores the foreign key None Source code in odmantic/reference.py def Reference ( * , key_name : Optional [ str ] = None ) -> Any : \"\"\"Used to define reference fields. Args: key_name: name of the Mongo key that stores the foreign key <!-- #noqa: DAR201 --> \"\"\" return ODMReferenceInfo ( key_name = key_name )","title":"odmantic.reference"},{"location":"api_reference/reference/#odmantic.reference.Reference","text":"Used to define reference fields. Parameters: Name Type Description Default key_name Optional[str] name of the Mongo key that stores the foreign key None Source code in odmantic/reference.py def Reference ( * , key_name : Optional [ str ] = None ) -> Any : \"\"\"Used to define reference fields. Args: key_name: name of the Mongo key that stores the foreign key <!-- #noqa: DAR201 --> \"\"\" return ODMReferenceInfo ( key_name = key_name )","title":"Reference()"}]}