{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ODMantic Documentation : https://art049.github.io/odmantic/ ODMantic is an Object Document Mapper (a kind of ORM but for NoSQL databases) for MongoDB based on standard python type hints. It's built on top of pydantic for model definition and validation. Core features: Simple : define your model by typing your fields using python types, build queries using python comparison operators Developer experience : field/method autocompletion, type hints Fully typed : leverage static analysis to reduce runtime issues AsyncIO : works well with ASGI frameworks ( FastAPI , Starlette , ...) Requirements Python : 3.6 and later (tested against 3.6, 3.7 and 3.8) MongoDB : 4.0 and later Two direct dependencies: pydantic : makes data validation and schema definition both handy and elegant. motor : an asyncio MongoDB driver officially developed by the MongoDB team. Installation pip install odmantic Example Define your first model from odmantic import Model , Field class Publisher ( Model ): name : str founded : int location : str = None Create some instances instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] Populate the database with your instances from odmantic import AIOEngine engine = AIOEngine () await engine . save_all ( instances ) Find instances matching specific criteria early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Update an instance lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) await engine . save ( lulu ) lulu . founded = 1439 #> ValidationError exception raised License This project is licensed under the terms of the ISC license .","title":"Overview"},{"location":"#requirements","text":"Python : 3.6 and later (tested against 3.6, 3.7 and 3.8) MongoDB : 4.0 and later Two direct dependencies: pydantic : makes data validation and schema definition both handy and elegant. motor : an asyncio MongoDB driver officially developed by the MongoDB team.","title":"Requirements"},{"location":"#installation","text":"pip install odmantic","title":"Installation"},{"location":"#example","text":"","title":"Example"},{"location":"#define-your-first-model","text":"from odmantic import Model , Field class Publisher ( Model ): name : str founded : int location : str = None","title":"Define your first model"},{"location":"#create-some-instances","text":"instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ]","title":"Create some instances"},{"location":"#populate-the-database-with-your-instances","text":"from odmantic import AIOEngine engine = AIOEngine () await engine . save_all ( instances )","title":"Populate the database with your instances"},{"location":"#find-instances-matching-specific-criteria","text":"early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None","title":"Find instances matching specific criteria"},{"location":"#update-an-instance","text":"lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) await engine . save ( lulu ) lulu . founded = 1439 #> ValidationError exception raised","title":"Update an instance"},{"location":"#license","text":"This project is licensed under the terms of the ISC license .","title":"License"},{"location":"changelog/","text":"","title":"Changelog"},{"location":"engine/","text":"Engine Creating the engine AsyncIO from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , db_name = \"example_db\" ) Create documents AsyncIO class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(name=\"Leeroy Jenkins\") Count documents AsyncIO count = await engine . count ( Player ) print ( count ) #> 3","title":"Engine"},{"location":"engine/#engine","text":"","title":"Engine"},{"location":"engine/#creating-the-engine","text":"AsyncIO from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , db_name = \"example_db\" )","title":"Creating the engine"},{"location":"engine/#create-documents","text":"AsyncIO class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(name=\"Leeroy Jenkins\")","title":"Create documents"},{"location":"engine/#count-documents","text":"AsyncIO count = await engine . count ( Player ) print ( count ) #> 3","title":"Count documents"},{"location":"fields/","text":"Fields Providing default values class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Zerator\" ) print ( p ) #> Player(name=\"Zerator\", level=0) Note For typing.Optional fields, None is already set to the default value Customize Mongo document naming class Player ( Model ): name : str = Field ( key_name = \"nickname\" ) await engine . save ( Player ( name = \"Jack\" )) Resulting document: { \"_id\" : ObjectId( \"5ed50fcad11d1975aa3d7a28\" ) , # See the next section for more details \"nickname\" : \"Jack\" , } Tip You can combine default values and custom field name by using the default keyword argument when building the field class Player ( Model ): name : str level : int = field ( default = 0 , key_name = \"lvl\" ) Primary key definition Implicit If not explicitly declared, an id primary key will be added to each model. It will be mapped to the _id key generated automatically by MongoDB). This id field will be generated on instance creation, before saving the instance to the database. class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\") Explicit If you want to use a field as the primary key Warning The Mongo name of the primary key field will be enforced to _id class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(name=\"Leeroy Jenkins\") Resulting document: { \"_id\" : \"Leeroy Jenkins\" }","title":"Fields"},{"location":"fields/#fields","text":"","title":"Fields"},{"location":"fields/#providing-default-values","text":"class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Zerator\" ) print ( p ) #> Player(name=\"Zerator\", level=0) Note For typing.Optional fields, None is already set to the default value","title":"Providing default values"},{"location":"fields/#customize-mongo-document-naming","text":"class Player ( Model ): name : str = Field ( key_name = \"nickname\" ) await engine . save ( Player ( name = \"Jack\" )) Resulting document: { \"_id\" : ObjectId( \"5ed50fcad11d1975aa3d7a28\" ) , # See the next section for more details \"nickname\" : \"Jack\" , } Tip You can combine default values and custom field name by using the default keyword argument when building the field class Player ( Model ): name : str level : int = field ( default = 0 , key_name = \"lvl\" )","title":"Customize Mongo document naming"},{"location":"fields/#primary-key-definition","text":"","title":"Primary key definition"},{"location":"fields/#implicit","text":"If not explicitly declared, an id primary key will be added to each model. It will be mapped to the _id key generated automatically by MongoDB). This id field will be generated on instance creation, before saving the instance to the database. class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\")","title":"Implicit"},{"location":"fields/#explicit","text":"If you want to use a field as the primary key Warning The Mongo name of the primary key field will be enforced to _id class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(name=\"Leeroy Jenkins\") Resulting document: { \"_id\" : \"Leeroy Jenkins\" }","title":"Explicit"},{"location":"filtering/","text":"","title":"Filtering"},{"location":"hate/","text":"I hate ORMs/ODMs","title":"I hate ORMs/ODMs"},{"location":"hate/#i-hate-ormsodms","text":"","title":"I hate ORMs/ODMs"},{"location":"modeling/","text":"Modeling Relations ? Embedded Models One to One relationships class Publisher ( EmbeddedModel ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher book = Book ( title = \"MongoDB: The Definitive Guide\" , pages = 216 , publisher = Publisher ( name = \"O'Reilly Media\" , founded = 1980 , location = \"CA\" ), ) await engine . add ( book ) Tip It is possible to build a define query filters on embedded documents book_from_CA = await engine . find_one ( Book , Book . publisher . location == \"CA\" ) print ( book_from_CA ) #> Book(title=\"MongoDB: The Definitive Guide\", pages=216, publisher=Publisher, name=\"O'Reilly Media\", founded=1980, location=\"CA\")) One to Many relationships class Address ( EmbeddedModel ): street : str city : str state : str zip : str class Patron ( Model ): name : str addresses : List [ Address ] Note To add conditions on the number of embedded elements, it's possible to pass extra arguments during the Embedded Field definition (TODO). Another possibility is to use the typing.Tuple type. Referenced Models class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference ()","title":"Modeling"},{"location":"modeling/#modeling","text":"","title":"Modeling"},{"location":"modeling/#relations","text":"","title":"Relations ?"},{"location":"modeling/#embedded-models","text":"","title":"Embedded Models"},{"location":"modeling/#one-to-one-relationships","text":"class Publisher ( EmbeddedModel ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher book = Book ( title = \"MongoDB: The Definitive Guide\" , pages = 216 , publisher = Publisher ( name = \"O'Reilly Media\" , founded = 1980 , location = \"CA\" ), ) await engine . add ( book ) Tip It is possible to build a define query filters on embedded documents book_from_CA = await engine . find_one ( Book , Book . publisher . location == \"CA\" ) print ( book_from_CA ) #> Book(title=\"MongoDB: The Definitive Guide\", pages=216, publisher=Publisher, name=\"O'Reilly Media\", founded=1980, location=\"CA\"))","title":"One to One relationships"},{"location":"modeling/#one-to-many-relationships","text":"class Address ( EmbeddedModel ): street : str city : str state : str zip : str class Patron ( Model ): name : str addresses : List [ Address ] Note To add conditions on the number of embedded elements, it's possible to pass extra arguments during the Embedded Field definition (TODO). Another possibility is to use the typing.Tuple type.","title":"One to Many relationships"},{"location":"modeling/#referenced-models","text":"class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference ()","title":"Referenced Models"},{"location":"quickstart/","text":"Quickstart Defining a model from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine , Model class Person ( Model ): first_name : str last_name : str Creating an instance person_instance = Person ( first_name = \"Robert\" , last_name = \"Miles\" ) print ( person_instance ) #> Person(first_name=\"Robert\", last_name=\"Miles\") print ( person_instance . first_name ) #> Robert print ( person_instance . last_name ) #> Miles Saving a created instance Creating an engine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , db_name = \"example_db\" ) Persisting an instance save python await engine.save(Person(first_name=\"Freddie\", last_name=\"Mercury\")) await engine.save(Person(first_name=\"Robert\", last_name=\"Miles\")) save_all python await engine.save_all([ Person(first_name=\"Freddie\", last_name=\"Mercury\"), Person(first_name=\"Robert\", last_name=\"Miles\") ]) Querying instances async for python cursor = engine.find(Person, Person.first_name == \"Freddie\") async for freddie in cursor: print(freddie) #> Person(first_name=\"Freddie\", last_name=\"Mercury\") await python freddies = await engine.find(Person, Person.first_name == \"Freddie\") print(freddies) #> [Person(first_name=\"Freddie\", last_name=\"Mercury\")]","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#defining-a-model","text":"from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine , Model class Person ( Model ): first_name : str last_name : str","title":"Defining a model"},{"location":"quickstart/#creating-an-instance","text":"person_instance = Person ( first_name = \"Robert\" , last_name = \"Miles\" ) print ( person_instance ) #> Person(first_name=\"Robert\", last_name=\"Miles\") print ( person_instance . first_name ) #> Robert print ( person_instance . last_name ) #> Miles","title":"Creating an instance"},{"location":"quickstart/#saving-a-created-instance","text":"","title":"Saving a created instance"},{"location":"quickstart/#creating-an-engine","text":"client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , db_name = \"example_db\" )","title":"Creating an engine"},{"location":"quickstart/#persisting-an-instance","text":"save python await engine.save(Person(first_name=\"Freddie\", last_name=\"Mercury\")) await engine.save(Person(first_name=\"Robert\", last_name=\"Miles\")) save_all python await engine.save_all([ Person(first_name=\"Freddie\", last_name=\"Mercury\"), Person(first_name=\"Robert\", last_name=\"Miles\") ])","title":"Persisting an instance"},{"location":"quickstart/#querying-instances","text":"async for python cursor = engine.find(Person, Person.first_name == \"Freddie\") async for freddie in cursor: print(freddie) #> Person(first_name=\"Freddie\", last_name=\"Mercury\") await python freddies = await engine.find(Person, Person.first_name == \"Freddie\") print(freddies) #> [Person(first_name=\"Freddie\", last_name=\"Mercury\")]","title":"Querying instances"},{"location":"types/","text":"Data types Supported BSON types ( bson package) Int64 (long) ObjectId (objectId) Decimal128 (decimal) Additionnaly, most of the types supported by pydantic are supported. See pydantic: Field Types for more details. Unsupported types typing.Set / set Python to BSON type mapping Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal is not supported yet str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array","title":"Data types"},{"location":"types/#data-types","text":"","title":"Data types"},{"location":"types/#supported-bson-types-bson-package","text":"Int64 (long) ObjectId (objectId) Decimal128 (decimal) Additionnaly, most of the types supported by pydantic are supported. See pydantic: Field Types for more details.","title":"Supported BSON types (bson package)"},{"location":"types/#unsupported-types","text":"typing.Set / set","title":"Unsupported types"},{"location":"types/#python-to-bson-type-mapping","text":"Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal is not supported yet str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array","title":"Python to BSON type mapping"},{"location":"api_reference/engine/","text":"odmantic.engine.AIOEngine zzz[]aaa The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = 'test' ) False zzz['special']aaa special Parameters: Name Type Description Default motor_client AsyncIOMotorClient instance of an AsyncIO motor client. If None, a default one None database str name of the database to use 'test' Source code in odmantic/engine.py def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\" Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use \"\"\" if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database = database self . database = motor_client [ self . database ] count ( self , model : Type [ ~ ModelType ], query : Union [ odmantic . query . QueryExpression , Dict , bool ] = {}) False zzz[]aaa Get the count of documents matching a query Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} Returns: Type Description int number of document matching the query Source code in odmantic/engine.py async def count ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = {} ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on query: query filter to apply Returns: number of document matching the query \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count ) delete ( self , instance : ~ ModelType ) False zzz[]aaa Delete an instance from the database Parameters: Name Type Description Default instance ~ModelType the instance to delete required Exceptions: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_key__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance ) find ( self , model : Type [ ~ ModelType ], query : Union [ odmantic . query . QueryExpression , Dict , bool ] = {}, * , limit : Optional [ int ] = None , skip : int = 0 ) False zzz[]aaa Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} limit Optional[int] maximum number of instance fetched None skip int number of document to skip 0 Returns: Type Description odmantic.engine.AIOCursor[~ModelType] [odmantic.engine.AIOCursor][] of the query Source code in odmantic/engine.py def find ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = QueryExpression (), # bool: allow using binary operators with mypy * , limit : Optional [ int ] = None , skip : int = 0 , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on query: query filter to apply limit: maximum number of instance fetched skip: number of document to skip Returns: [odmantic.engine.AIOCursor][] of the query \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) collection = self . _get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor ) find_one ( self , model : Type [ ~ ModelType ], query : Union [ odmantic . query . QueryExpression , Dict , bool ] = {}) False zzz[]aaa Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} Returns: Type Description Optional[~ModelType] the fetched instance if found otherwise None Source code in odmantic/engine.py async def find_one ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = QueryExpression (), # bool: allow using binary operators w/o plugin ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on query: query filter to apply Returns: the fetched instance if found otherwise None \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , query , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ] save ( self , instance : ~ ModelType ) False zzz[]aaa Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ~ModelType instance to persist required Returns: Type Description ~ModelType the saved instance Note The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py async def save ( self , instance : ModelType ) -> ModelType : \"\"\" Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance save_all ( self , instances : Sequence [ ~ ModelType ]) False zzz[]aaa Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence[~ModelType] instances to persist required Returns: Type Description List[~ModelType] the saved instances Note The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\" Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances odmantic.engine.AIOCursor zzz[]aaa This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models","title":"Engine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine","text":"The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor.","title":"AIOEngine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.__init__","text":"Parameters: Name Type Description Default motor_client AsyncIOMotorClient instance of an AsyncIO motor client. If None, a default one None database str name of the database to use 'test' Source code in odmantic/engine.py def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\" Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use \"\"\" if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database = database self . database = motor_client [ self . database ]","title":"__init__()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.count","text":"Get the count of documents matching a query Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} Returns: Type Description int number of document matching the query Source code in odmantic/engine.py async def count ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = {} ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on query: query filter to apply Returns: number of document matching the query \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count )","title":"count()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.delete","text":"Delete an instance from the database Parameters: Name Type Description Default instance ~ModelType the instance to delete required Exceptions: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_key__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance )","title":"delete()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find","text":"Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} limit Optional[int] maximum number of instance fetched None skip int number of document to skip 0 Returns: Type Description odmantic.engine.AIOCursor[~ModelType] [odmantic.engine.AIOCursor][] of the query Source code in odmantic/engine.py def find ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = QueryExpression (), # bool: allow using binary operators with mypy * , limit : Optional [ int ] = None , skip : int = 0 , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on query: query filter to apply limit: maximum number of instance fetched skip: number of document to skip Returns: [odmantic.engine.AIOCursor][] of the query \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) collection = self . _get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor )","title":"find()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find_one","text":"Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} Returns: Type Description Optional[~ModelType] the fetched instance if found otherwise None Source code in odmantic/engine.py async def find_one ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = QueryExpression (), # bool: allow using binary operators w/o plugin ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on query: query filter to apply Returns: the fetched instance if found otherwise None \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , query , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ]","title":"find_one()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save","text":"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ~ModelType instance to persist required Returns: Type Description ~ModelType the saved instance Note The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py async def save ( self , instance : ModelType ) -> ModelType : \"\"\" Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance","title":"save()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save_all","text":"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence[~ModelType] instances to persist required Returns: Type Description List[~ModelType] the saved instances Note The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\" Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances","title":"save_all()"},{"location":"api_reference/engine/#odmantic.engine.AIOCursor","text":"This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models","title":"AIOCursor"},{"location":"api_reference/exceptions/","text":"odmantic.exceptions.BaseEngineException zzz[]aaa Base Exception raised by the engine while operating on a model odmantic.exceptions.DocumentNotFoundError zzz[]aaa The targetted document has not been found by the engine Attributes: Name Type Description instance Model the instance that has not been found","title":"Exceptions"},{"location":"api_reference/exceptions/#odmantic.exceptions.BaseEngineException","text":"Base Exception raised by the engine while operating on a model","title":"BaseEngineException"},{"location":"api_reference/exceptions/#odmantic.exceptions.DocumentNotFoundError","text":"The targetted document has not been found by the engine Attributes: Name Type Description instance Model the instance that has not been found","title":"DocumentNotFoundError"},{"location":"api_reference/field/","text":"","title":"Field"},{"location":"api_reference/model/","text":"::: odmantic.model._BaseODMModel odmantic.model.Model zzz['pydantic-model']aaa pydantic-model odmantic.model.EmbeddedModel zzz['pydantic-model']aaa pydantic-model","title":"Model"},{"location":"api_reference/model/#odmantic.model.Model","text":"","title":"Model"},{"location":"api_reference/model/#odmantic.model.EmbeddedModel","text":"","title":"EmbeddedModel"},{"location":"api_reference/reference/","text":"","title":"Reference"}]}