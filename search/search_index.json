{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ODMantic Documentation : https://art049.github.io/odmantic/ ODMantic is an Object Document Mapper (a kind of ORM but for NoSQL databases) for MongoDB based on standard python type hints. It's built on top of pydantic for model definition and validation. Core features: Simple : define your model by typing your fields using python types, build queries using python comparison operators Developer experience : field/method autocompletion, type hints Fully typed : leverage static analysis to reduce runtime issues AsyncIO : works well with ASGI frameworks ( FastAPI , Starlette , ...) Requirements \u00b6 Python : 3.6 and later (tested against 3.6, 3.7 and 3.8) MongoDB : 4.0 and later Two direct dependencies: pydantic : makes data validation and schema definition both handy and elegant. motor : an asyncio MongoDB driver officially developed by the MongoDB team. Installation \u00b6 pip install odmantic Example \u00b6 To enjoy an async context without any code boilerplate, it's strongly advised to run the following steps with IPython . Define your first model \u00b6 from typing import Optional from odmantic import Field , Model class Publisher ( Model ): name : str founded : int = Field ( gte = 1440 ) location : Optional [ str ] = None By defining the Publisher class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers. This model contains three fields: name : This is the name of the Publisher. This is a simple string field without any specific validation but it will be required to build a new Publisher. founded : This is the year of foundation of the Publisher. Since the printing press has been invented in 1440, it would be handy to allow only values above 1440. The gte keyword argument passed to the Field is exactly doing this. The model will require a founded value greater or equal than 1440. location : This field will contain the country code of the Publisher. Defining this field as Optional with a None default value makes it a non required field that will be set automatically when not specified. The collection name has been defined by ODMantic as well. In this case it will be publisher . Create some instances \u00b6 instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] We defined three instances of the Publisher model. They all have a name property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to None (it will be stored as null in the database). For now, those instances only exists locally. We will persist them in a database in the next step. Populate the database with your instances \u00b6 For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container). docker run --rm --net = host mongo First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object. from odmantic import AIOEngine engine = AIOEngine () By default, the AIOEngine (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named test by default. The next step is to persist the instances we created before. We can perform this operation using the AIOEngine.save_all method. await engine . save_all ( instances ) Most of the engine I/O methods are asynchronous, hence the await keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface. Another possibility is to use mongo cli directly: mongo --eval \"db.publisher.find({})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54c9\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54ca\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : null , \"name\" : \"Lulu\" } The created instances are stored in the test database under the publisher collection. We can see that an _id field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name id . print ( instances [ 0 ] . id ) #> ObjectId(\"5f67b331514d6855bc5c54c9\") Find instances matching a criteria \u00b6 Since we now have some documents in the database, we can start building some queries. First, let's find publishers created before the 2000s: early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] Here, we called the engine.find method. The first argument we need to specify is the Model class we want to query on (in our case Publisher ). The second argument is the actual query. Similarly to SQLAlchemy , you can build ODMantic queries using the regular python operators. When awaited, the engine.find method will return the list of matching instances stored in the database. Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA): ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Here the result is None because no matching instances have been found in the database. The engine.find_one method returns an instance if one exists in the database otherwise, it will return None . Modify an instance \u00b6 Finally, let's edit some instances. For example, we can set the location for the publisher named Lulu . First, we need to gather the instance from the database: lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=None) We still have the same instance, with no location set. We can change this field: lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) The location has been changed locally but the last step to persist this change is to save the document: await engine . save ( lulu ) We can now check the database state: mongo --eval \"db.publisher.find({name: 'Lulu'})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : \"US\" , \"name\" : \"Lulu\" } The document have been successfully updated ! Now, what if we would like to change the foundation date with an invalid one (before 1440) ? lulu . founded = 1000 #> ValidationError: 1 validation error for Publisher #> founded #> ensure this value is greater than 1440 #> (type=value_error.number.not_gt; limit_value=1440) This will raise an exception as it's not matching the model definition. The raised exception is actually a ValidationError created by from pydantic . To get started on more advanced practices like relations and building more advanced queries, you can go to the Quickstart section . License \u00b6 This project is licensed under the terms of the ISC license .","title":"Overview"},{"location":"#requirements","text":"Python : 3.6 and later (tested against 3.6, 3.7 and 3.8) MongoDB : 4.0 and later Two direct dependencies: pydantic : makes data validation and schema definition both handy and elegant. motor : an asyncio MongoDB driver officially developed by the MongoDB team.","title":"Requirements"},{"location":"#installation","text":"pip install odmantic","title":"Installation"},{"location":"#example","text":"To enjoy an async context without any code boilerplate, it's strongly advised to run the following steps with IPython .","title":"Example"},{"location":"#define-your-first-model","text":"from typing import Optional from odmantic import Field , Model class Publisher ( Model ): name : str founded : int = Field ( gte = 1440 ) location : Optional [ str ] = None By defining the Publisher class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers. This model contains three fields: name : This is the name of the Publisher. This is a simple string field without any specific validation but it will be required to build a new Publisher. founded : This is the year of foundation of the Publisher. Since the printing press has been invented in 1440, it would be handy to allow only values above 1440. The gte keyword argument passed to the Field is exactly doing this. The model will require a founded value greater or equal than 1440. location : This field will contain the country code of the Publisher. Defining this field as Optional with a None default value makes it a non required field that will be set automatically when not specified. The collection name has been defined by ODMantic as well. In this case it will be publisher .","title":"Define your first model"},{"location":"#create-some-instances","text":"instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] We defined three instances of the Publisher model. They all have a name property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to None (it will be stored as null in the database). For now, those instances only exists locally. We will persist them in a database in the next step.","title":"Create some instances"},{"location":"#populate-the-database-with-your-instances","text":"For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container). docker run --rm --net = host mongo First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object. from odmantic import AIOEngine engine = AIOEngine () By default, the AIOEngine (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named test by default. The next step is to persist the instances we created before. We can perform this operation using the AIOEngine.save_all method. await engine . save_all ( instances ) Most of the engine I/O methods are asynchronous, hence the await keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface. Another possibility is to use mongo cli directly: mongo --eval \"db.publisher.find({})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54c9\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54ca\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : null , \"name\" : \"Lulu\" } The created instances are stored in the test database under the publisher collection. We can see that an _id field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name id . print ( instances [ 0 ] . id ) #> ObjectId(\"5f67b331514d6855bc5c54c9\")","title":"Populate the database with your instances"},{"location":"#find-instances-matching-a-criteria","text":"Since we now have some documents in the database, we can start building some queries. First, let's find publishers created before the 2000s: early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] Here, we called the engine.find method. The first argument we need to specify is the Model class we want to query on (in our case Publisher ). The second argument is the actual query. Similarly to SQLAlchemy , you can build ODMantic queries using the regular python operators. When awaited, the engine.find method will return the list of matching instances stored in the database. Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA): ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Here the result is None because no matching instances have been found in the database. The engine.find_one method returns an instance if one exists in the database otherwise, it will return None .","title":"Find instances matching a criteria"},{"location":"#modify-an-instance","text":"Finally, let's edit some instances. For example, we can set the location for the publisher named Lulu . First, we need to gather the instance from the database: lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=None) We still have the same instance, with no location set. We can change this field: lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) The location has been changed locally but the last step to persist this change is to save the document: await engine . save ( lulu ) We can now check the database state: mongo --eval \"db.publisher.find({name: 'Lulu'})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : \"US\" , \"name\" : \"Lulu\" } The document have been successfully updated ! Now, what if we would like to change the foundation date with an invalid one (before 1440) ? lulu . founded = 1000 #> ValidationError: 1 validation error for Publisher #> founded #> ensure this value is greater than 1440 #> (type=value_error.number.not_gt; limit_value=1440) This will raise an exception as it's not matching the model definition. The raised exception is actually a ValidationError created by from pydantic . To get started on more advanced practices like relations and building more advanced queries, you can go to the Quickstart section .","title":"Modify an instance"},{"location":"#license","text":"This project is licensed under the terms of the ISC license .","title":"License"},{"location":"changelog/","text":"","title":"Changelog"},{"location":"engine/","text":"Engine \u00b6 Creating the engine \u00b6 AsyncIO from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , db_name = \"example_db\" ) Create documents \u00b6 AsyncIO class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(name=\"Leeroy Jenkins\") Count documents \u00b6 AsyncIO count = await engine . count ( Player ) print ( count ) #> 3","title":"Engine"},{"location":"engine/#engine","text":"","title":"Engine"},{"location":"engine/#creating-the-engine","text":"AsyncIO from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , db_name = \"example_db\" )","title":"Creating the engine"},{"location":"engine/#create-documents","text":"AsyncIO class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(name=\"Leeroy Jenkins\")","title":"Create documents"},{"location":"engine/#count-documents","text":"AsyncIO count = await engine . count ( Player ) print ( count ) #> 3","title":"Count documents"},{"location":"fields/","text":"Fields \u00b6 Providing default values \u00b6 class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Zerator\" ) print ( p ) #> Player(name=\"Zerator\", level=0) Note For typing.Optional fields, None is already set to the default value Customize Mongo document naming \u00b6 class Player ( Model ): name : str = Field ( key_name = \"nickname\" ) await engine . save ( Player ( name = \"Jack\" )) Resulting document: { \"_id\" : ObjectId( \"5ed50fcad11d1975aa3d7a28\" ) , # See the next section for more details \"nickname\" : \"Jack\" , } Tip You can combine default values and custom field name by using the default keyword argument when building the field class Player ( Model ): name : str level : int = field ( default = 0 , key_name = \"lvl\" ) Primary key definition \u00b6 Implicit \u00b6 If not explicitly declared, an id primary key will be added to each model. It will be mapped to the _id key generated automatically by MongoDB). This id field will be generated on instance creation, before saving the instance to the database. class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\") Explicit \u00b6 If you want to use a field as the primary key Warning The Mongo name of the primary key field will be enforced to _id class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(name=\"Leeroy Jenkins\") Resulting document: { \"_id\" : \"Leeroy Jenkins\" }","title":"Fields"},{"location":"fields/#fields","text":"","title":"Fields"},{"location":"fields/#providing-default-values","text":"class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Zerator\" ) print ( p ) #> Player(name=\"Zerator\", level=0) Note For typing.Optional fields, None is already set to the default value","title":"Providing default values"},{"location":"fields/#customize-mongo-document-naming","text":"class Player ( Model ): name : str = Field ( key_name = \"nickname\" ) await engine . save ( Player ( name = \"Jack\" )) Resulting document: { \"_id\" : ObjectId( \"5ed50fcad11d1975aa3d7a28\" ) , # See the next section for more details \"nickname\" : \"Jack\" , } Tip You can combine default values and custom field name by using the default keyword argument when building the field class Player ( Model ): name : str level : int = field ( default = 0 , key_name = \"lvl\" )","title":"Customize Mongo document naming"},{"location":"fields/#primary-key-definition","text":"","title":"Primary key definition"},{"location":"fields/#implicit","text":"If not explicitly declared, an id primary key will be added to each model. It will be mapped to the _id key generated automatically by MongoDB). This id field will be generated on instance creation, before saving the instance to the database. class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\")","title":"Implicit"},{"location":"fields/#explicit","text":"If you want to use a field as the primary key Warning The Mongo name of the primary key field will be enforced to _id class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) await engine . save ( leeroy ) print ( leeroy ) #> Player(name=\"Leeroy Jenkins\") Resulting document: { \"_id\" : \"Leeroy Jenkins\" }","title":"Explicit"},{"location":"filtering/","text":"","title":"Filtering"},{"location":"hate/","text":"I hate ORMs/ODMs \u00b6","title":"I hate ORMs/ODMs"},{"location":"hate/#i-hate-ormsodms","text":"","title":"I hate ORMs/ODMs"},{"location":"modeling/","text":"Modeling \u00b6 Relations ? \u00b6 Embedded Models \u00b6 One to One relationships \u00b6 class Publisher ( EmbeddedModel ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher book = Book ( title = \"MongoDB: The Definitive Guide\" , pages = 216 , publisher = Publisher ( name = \"O'Reilly Media\" , founded = 1980 , location = \"CA\" ), ) await engine . add ( book ) Tip It is possible to build a define query filters on embedded documents book_from_CA = await engine . find_one ( Book , Book . publisher . location == \"CA\" ) print ( book_from_CA ) #> Book(title=\"MongoDB: The Definitive Guide\", pages=216, publisher=Publisher, name=\"O'Reilly Media\", founded=1980, location=\"CA\")) One to Many relationships \u00b6 class Address ( EmbeddedModel ): street : str city : str state : str zip : str class Patron ( Model ): name : str addresses : List [ Address ] Note To add conditions on the number of embedded elements, it's possible to pass extra arguments during the Embedded Field definition (TODO). Another possibility is to use the typing.Tuple type. Referenced Models \u00b6 class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference ()","title":"Modeling"},{"location":"modeling/#modeling","text":"","title":"Modeling"},{"location":"modeling/#relations","text":"","title":"Relations ?"},{"location":"modeling/#embedded-models","text":"","title":"Embedded Models"},{"location":"modeling/#one-to-one-relationships","text":"class Publisher ( EmbeddedModel ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher book = Book ( title = \"MongoDB: The Definitive Guide\" , pages = 216 , publisher = Publisher ( name = \"O'Reilly Media\" , founded = 1980 , location = \"CA\" ), ) await engine . add ( book ) Tip It is possible to build a define query filters on embedded documents book_from_CA = await engine . find_one ( Book , Book . publisher . location == \"CA\" ) print ( book_from_CA ) #> Book(title=\"MongoDB: The Definitive Guide\", pages=216, publisher=Publisher, name=\"O'Reilly Media\", founded=1980, location=\"CA\"))","title":"One to One relationships"},{"location":"modeling/#one-to-many-relationships","text":"class Address ( EmbeddedModel ): street : str city : str state : str zip : str class Patron ( Model ): name : str addresses : List [ Address ] Note To add conditions on the number of embedded elements, it's possible to pass extra arguments during the Embedded Field definition (TODO). Another possibility is to use the typing.Tuple type.","title":"One to Many relationships"},{"location":"modeling/#referenced-models","text":"class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference ()","title":"Referenced Models"},{"location":"quickstart/","text":"Quickstart \u00b6 Defining a model \u00b6 from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine , Model class Person ( Model ): first_name : str last_name : str Creating an instance \u00b6 person_instance = Person ( first_name = \"Robert\" , last_name = \"Miles\" ) print ( person_instance ) #> Person(first_name=\"Robert\", last_name=\"Miles\") print ( person_instance . first_name ) #> Robert print ( person_instance . last_name ) #> Miles Saving a created instance \u00b6 Creating an engine \u00b6 client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , db_name = \"example_db\" ) Persisting an instance \u00b6 save python await engine.save(Person(first_name=\"Freddie\", last_name=\"Mercury\")) await engine.save(Person(first_name=\"Robert\", last_name=\"Miles\")) save_all python await engine.save_all([ Person(first_name=\"Freddie\", last_name=\"Mercury\"), Person(first_name=\"Robert\", last_name=\"Miles\") ]) Querying instances \u00b6 async for python cursor = engine.find(Person, Person.first_name == \"Freddie\") async for freddie in cursor: print(freddie) #> Person(first_name=\"Freddie\", last_name=\"Mercury\") await python freddies = await engine.find(Person, Person.first_name == \"Freddie\") print(freddies) #> [Person(first_name=\"Freddie\", last_name=\"Mercury\")]","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#defining-a-model","text":"from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine , Model class Person ( Model ): first_name : str last_name : str","title":"Defining a model"},{"location":"quickstart/#creating-an-instance","text":"person_instance = Person ( first_name = \"Robert\" , last_name = \"Miles\" ) print ( person_instance ) #> Person(first_name=\"Robert\", last_name=\"Miles\") print ( person_instance . first_name ) #> Robert print ( person_instance . last_name ) #> Miles","title":"Creating an instance"},{"location":"quickstart/#saving-a-created-instance","text":"","title":"Saving a created instance"},{"location":"quickstart/#creating-an-engine","text":"client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , db_name = \"example_db\" )","title":"Creating an engine"},{"location":"quickstart/#persisting-an-instance","text":"save python await engine.save(Person(first_name=\"Freddie\", last_name=\"Mercury\")) await engine.save(Person(first_name=\"Robert\", last_name=\"Miles\")) save_all python await engine.save_all([ Person(first_name=\"Freddie\", last_name=\"Mercury\"), Person(first_name=\"Robert\", last_name=\"Miles\") ])","title":"Persisting an instance"},{"location":"quickstart/#querying-instances","text":"async for python cursor = engine.find(Person, Person.first_name == \"Freddie\") async for freddie in cursor: print(freddie) #> Person(first_name=\"Freddie\", last_name=\"Mercury\") await python freddies = await engine.find(Person, Person.first_name == \"Freddie\") print(freddies) #> [Person(first_name=\"Freddie\", last_name=\"Mercury\")]","title":"Querying instances"},{"location":"types/","text":"Data types \u00b6 Supported BSON types ( bson package) \u00b6 Int64 (long) ObjectId (objectId) Decimal128 (decimal) Additionnaly, most of the types supported by pydantic are supported. See pydantic: Field Types for more details. Unsupported types \u00b6 typing.Set / set Python to BSON type mapping \u00b6 Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal decimal str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array","title":"Data types"},{"location":"types/#data-types","text":"","title":"Data types"},{"location":"types/#supported-bson-types-bson-package","text":"Int64 (long) ObjectId (objectId) Decimal128 (decimal) Additionnaly, most of the types supported by pydantic are supported. See pydantic: Field Types for more details.","title":"Supported BSON types (bson package)"},{"location":"types/#unsupported-types","text":"typing.Set / set","title":"Unsupported types"},{"location":"types/#python-to-bson-type-mapping","text":"Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal decimal str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array","title":"Python to BSON type mapping"},{"location":"api_reference/engine/","text":"odmantic.engine.AIOEngine \u00b6 The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. __init__ ( self , motor_client = None , database = 'test' ) special \u00b6 Parameters: Name Type Description Default motor_client AsyncIOMotorClient instance of an AsyncIO motor client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\" Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use \"\"\" # https://docs.mongodb.com/manual/reference/limits/#naming-restrictions forbidden_characters = _FORBIDDEN_DATABASE_CHARACTERS . intersection ( set ( database ) ) if len ( forbidden_characters ) > 0 : raise ValueError ( f \"database name cannot contain: { ' ' . join ( forbidden_characters ) } \" ) if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database_name = database self . database = motor_client [ self . database_name ] count ( self , model , query = {}) async \u00b6 Get the count of documents matching a query Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} Returns: Type Description int number of document matching the query Source code in odmantic/engine.py async def count ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = {} ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on query: query filter to apply Returns: number of document matching the query \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count ) delete ( self , instance ) async \u00b6 Delete an instance from the database Parameters: Name Type Description Default instance ~ModelType the instance to delete required Exceptions: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_key__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance ) find ( self , model , query = {}, * , limit = None , skip = 0 ) \u00b6 Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} limit Optional[int] maximum number of instance fetched None skip int number of document to skip 0 Returns: Type Description odmantic.engine.AIOCursor[~ModelType] [odmantic.engine.AIOCursor][] of the query Source code in odmantic/engine.py def find ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = QueryExpression (), # bool: allow using binary operators with mypy * , limit : Optional [ int ] = None , skip : int = 0 , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on query: query filter to apply limit: maximum number of instance fetched skip: number of document to skip Returns: [odmantic.engine.AIOCursor][] of the query \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) collection = self . _get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor ) find_one ( self , model , query = {}) async \u00b6 Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} Returns: Type Description Optional[~ModelType] the fetched instance if found otherwise None Source code in odmantic/engine.py async def find_one ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = QueryExpression (), # bool: allow using binary operators w/o plugin ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on query: query filter to apply Returns: the fetched instance if found otherwise None \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , query , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ] save ( self , instance ) async \u00b6 Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ~ModelType instance to persist required Returns: Type Description ~ModelType the saved instance Note The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py async def save ( self , instance : ModelType ) -> ModelType : \"\"\" Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance save_all ( self , instances ) async \u00b6 Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence[~ModelType] instances to persist required Returns: Type Description List[~ModelType] the saved instances Note The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\" Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances odmantic.engine.AIOCursor \u00b6 This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models","title":"Engine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine","text":"The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor.","title":"AIOEngine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.__init__","text":"Parameters: Name Type Description Default motor_client AsyncIOMotorClient instance of an AsyncIO motor client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\" Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use \"\"\" # https://docs.mongodb.com/manual/reference/limits/#naming-restrictions forbidden_characters = _FORBIDDEN_DATABASE_CHARACTERS . intersection ( set ( database ) ) if len ( forbidden_characters ) > 0 : raise ValueError ( f \"database name cannot contain: { ' ' . join ( forbidden_characters ) } \" ) if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database_name = database self . database = motor_client [ self . database_name ]","title":"__init__()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.count","text":"Get the count of documents matching a query Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} Returns: Type Description int number of document matching the query Source code in odmantic/engine.py async def count ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = {} ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on query: query filter to apply Returns: number of document matching the query \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count )","title":"count()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.delete","text":"Delete an instance from the database Parameters: Name Type Description Default instance ~ModelType the instance to delete required Exceptions: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_key__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance )","title":"delete()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find","text":"Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} limit Optional[int] maximum number of instance fetched None skip int number of document to skip 0 Returns: Type Description odmantic.engine.AIOCursor[~ModelType] [odmantic.engine.AIOCursor][] of the query Source code in odmantic/engine.py def find ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = QueryExpression (), # bool: allow using binary operators with mypy * , limit : Optional [ int ] = None , skip : int = 0 , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on query: query filter to apply limit: maximum number of instance fetched skip: number of document to skip Returns: [odmantic.engine.AIOCursor][] of the query \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) collection = self . _get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor )","title":"find()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find_one","text":"Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required query Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply {} Returns: Type Description Optional[~ModelType] the fetched instance if found otherwise None Source code in odmantic/engine.py async def find_one ( self , model : Type [ ModelType ], query : Union [ QueryExpression , Dict , bool ] = QueryExpression (), # bool: allow using binary operators w/o plugin ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on query: query filter to apply Returns: the fetched instance if found otherwise None \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , query , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ]","title":"find_one()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save","text":"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ~ModelType instance to persist required Returns: Type Description ~ModelType the saved instance Note The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py async def save ( self , instance : ModelType ) -> ModelType : \"\"\" Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance","title":"save()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save_all","text":"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence[~ModelType] instances to persist required Returns: Type Description List[~ModelType] the saved instances Note The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\" Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances","title":"save_all()"},{"location":"api_reference/engine/#odmantic.engine.AIOCursor","text":"This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models","title":"AIOCursor"},{"location":"api_reference/exceptions/","text":"odmantic.exceptions.BaseEngineException \u00b6 Base Exception raised by the engine while operating on a model odmantic.exceptions.DocumentNotFoundError \u00b6 The targetted document has not been found by the engine Attributes: Name Type Description instance Model the instance that has not been found","title":"Exceptions"},{"location":"api_reference/exceptions/#odmantic.exceptions.BaseEngineException","text":"Base Exception raised by the engine while operating on a model","title":"BaseEngineException"},{"location":"api_reference/exceptions/#odmantic.exceptions.DocumentNotFoundError","text":"The targetted document has not been found by the engine Attributes: Name Type Description instance Model the instance that has not been found","title":"DocumentNotFoundError"},{"location":"api_reference/field/","text":"odmantic.field.Field ( default = PydanticUndefined , * , key_name = None , primary_field = False , default_factory = None , title = None , description = None , const = None , gt = None , ge = None , lt = None , le = None , multiple_of = None , min_items = None , max_items = None , min_length = None , max_length = None , regex = None , ** extra ) \u00b6 Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields ( int , float , Decimal ) and some apply only to str . :param default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis ( ... ) to indicate the field has no default value :param key_name: the name to use in the the document structure :param primary_field: this field should be considered as a primary key. Can't be used along with key_name since the key_name will be set to _id :param default_factory: callable that will be called when a default value is needed for this field. If both default and default_factory are set, an error is raised. :param alias: Not supported by odmantic yet (the public name of the field) :param title: can be any string, used in the schema :param description: can be any string, used in the schema :param const: this field is required and must take it's default value :param gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword :param ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword :param lt: only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword :param le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a maximum validation keyword :param multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a multipleOf validation keyword :param min_length: only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword :param max_length: only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword :param regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a pattern validation keyword :param **extra: any additional keyword arguments will be added as is to the schema Source code in odmantic/field.py def Field ( default : Any = Undefined , * , key_name : Optional [ str ] = None , primary_field : bool = False , default_factory : Optional [ NoArgAnyCallable ] = None , # alias: str = None, not supported yet title : Optional [ str ] = None , description : Optional [ str ] = None , const : Optional [ bool ] = None , gt : Optional [ float ] = None , ge : Optional [ float ] = None , lt : Optional [ float ] = None , le : Optional [ float ] = None , multiple_of : Optional [ float ] = None , min_items : Optional [ int ] = None , max_items : Optional [ int ] = None , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , regex : Optional [ str ] = None , ** extra : Any , ) -> Any : \"\"\" Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. :param default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field has no default value :param key_name: the name to use in the the document structure :param primary_field: this field should be considered as a primary key. Can't be used along with `key_name` since the key_name will be set to `_id` :param default_factory: callable that will be called when a default value is needed for this field. If both `default` and `default_factory` are set, an error is raised. :param alias: Not supported by odmantic yet (the public name of the field) :param title: can be any string, used in the schema :param description: can be any string, used in the schema :param const: this field is required and *must* take it's default value :param gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an ``exclusiveMinimum`` validation keyword :param ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a ``minimum`` validation keyword :param lt: only applies to numbers, requires the field to be \"less than\". The schema will have an ``exclusiveMaximum`` validation keyword :param le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a ``maximum`` validation keyword :param multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a ``multipleOf`` validation keyword :param min_length: only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword :param max_length: only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword :param regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a ``pattern`` validation keyword :param **extra: any additional keyword arguments will be added as is to the schema \"\"\" # Perform casts on optional fields to avoid incompatibility due to the strict # optional mypy setting pydantic_field = PDField ( default , default_factory = default_factory , # alias=alias, # FIXME check aliases compatibility title = cast ( str , title ), description = cast ( str , description ), const = cast ( bool , const ), gt = cast ( float , gt ), ge = cast ( float , ge ), lt = cast ( float , lt ), le = cast ( float , le ), multiple_of = cast ( float , multiple_of ), min_items = cast ( int , min_items ), max_items = cast ( int , max_items ), min_length = cast ( int , min_length ), max_length = cast ( int , max_length ), regex = cast ( str , regex ), ** extra , ) if primary_field : if key_name is not None and key_name != \"_id\" : raise ValueError ( \"cannot specify a primary field with a custom key_name,\" \"key_name='_id' enforced\" ) else : key_name = \"_id\" elif key_name == \"_id\" : raise ValueError ( \"cannot specify key_name='_id' without defining the field as primary\" ) return ODMFieldInfo ( pydantic_field_info = pydantic_field , primary_field = primary_field , key_name = key_name , )","title":"Field"},{"location":"api_reference/field/#odmantic.field.Field","text":"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields ( int , float , Decimal ) and some apply only to str . :param default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis ( ... ) to indicate the field has no default value :param key_name: the name to use in the the document structure :param primary_field: this field should be considered as a primary key. Can't be used along with key_name since the key_name will be set to _id :param default_factory: callable that will be called when a default value is needed for this field. If both default and default_factory are set, an error is raised. :param alias: Not supported by odmantic yet (the public name of the field) :param title: can be any string, used in the schema :param description: can be any string, used in the schema :param const: this field is required and must take it's default value :param gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword :param ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword :param lt: only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword :param le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a maximum validation keyword :param multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a multipleOf validation keyword :param min_length: only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword :param max_length: only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword :param regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a pattern validation keyword :param **extra: any additional keyword arguments will be added as is to the schema Source code in odmantic/field.py def Field ( default : Any = Undefined , * , key_name : Optional [ str ] = None , primary_field : bool = False , default_factory : Optional [ NoArgAnyCallable ] = None , # alias: str = None, not supported yet title : Optional [ str ] = None , description : Optional [ str ] = None , const : Optional [ bool ] = None , gt : Optional [ float ] = None , ge : Optional [ float ] = None , lt : Optional [ float ] = None , le : Optional [ float ] = None , multiple_of : Optional [ float ] = None , min_items : Optional [ int ] = None , max_items : Optional [ int ] = None , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , regex : Optional [ str ] = None , ** extra : Any , ) -> Any : \"\"\" Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. :param default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field has no default value :param key_name: the name to use in the the document structure :param primary_field: this field should be considered as a primary key. Can't be used along with `key_name` since the key_name will be set to `_id` :param default_factory: callable that will be called when a default value is needed for this field. If both `default` and `default_factory` are set, an error is raised. :param alias: Not supported by odmantic yet (the public name of the field) :param title: can be any string, used in the schema :param description: can be any string, used in the schema :param const: this field is required and *must* take it's default value :param gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an ``exclusiveMinimum`` validation keyword :param ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a ``minimum`` validation keyword :param lt: only applies to numbers, requires the field to be \"less than\". The schema will have an ``exclusiveMaximum`` validation keyword :param le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a ``maximum`` validation keyword :param multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a ``multipleOf`` validation keyword :param min_length: only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword :param max_length: only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword :param regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a ``pattern`` validation keyword :param **extra: any additional keyword arguments will be added as is to the schema \"\"\" # Perform casts on optional fields to avoid incompatibility due to the strict # optional mypy setting pydantic_field = PDField ( default , default_factory = default_factory , # alias=alias, # FIXME check aliases compatibility title = cast ( str , title ), description = cast ( str , description ), const = cast ( bool , const ), gt = cast ( float , gt ), ge = cast ( float , ge ), lt = cast ( float , lt ), le = cast ( float , le ), multiple_of = cast ( float , multiple_of ), min_items = cast ( int , min_items ), max_items = cast ( int , max_items ), min_length = cast ( int , min_length ), max_length = cast ( int , max_length ), regex = cast ( str , regex ), ** extra , ) if primary_field : if key_name is not None and key_name != \"_id\" : raise ValueError ( \"cannot specify a primary field with a custom key_name,\" \"key_name='_id' enforced\" ) else : key_name = \"_id\" elif key_name == \"_id\" : raise ValueError ( \"cannot specify key_name='_id' without defining the field as primary\" ) return ODMFieldInfo ( pydantic_field_info = pydantic_field , primary_field = primary_field , key_name = key_name , )","title":"Field()"},{"location":"api_reference/model/","text":"Model \u00b6 odmantic.model.Model \u00b6 odmantic.model.EmbeddedModel \u00b6","title":"Model"},{"location":"api_reference/model/#model","text":"","title":"Model"},{"location":"api_reference/model/#odmantic.model.Model","text":"","title":"Model"},{"location":"api_reference/model/#odmantic.model.EmbeddedModel","text":"","title":"EmbeddedModel"},{"location":"api_reference/query/","text":"Query \u00b6 odmantic.query.QueryExpression \u00b6 Logical Operators \u00b6 odmantic.query.and_ ( * elements ) \u00b6 Source code in odmantic/query.py def and_ ( * elements : Union [ QueryExpression , bool ]) -> QueryExpression : return QueryExpression ({ \"$and\" : elements }) odmantic.query.or_ ( * elements ) \u00b6 Source code in odmantic/query.py def or_ ( * elements : Union [ QueryExpression , bool ]) -> QueryExpression : return QueryExpression ({ \"$or\" : elements }) odmantic.query.nor_ ( * elements ) \u00b6 Source code in odmantic/query.py def nor_ ( * elements : Union [ QueryExpression , bool ]) -> QueryExpression : return QueryExpression ({ \"$nor\" : elements }) Comparison Operators \u00b6 odmantic.query.eq ( field , value ) \u00b6 Source code in odmantic/query.py def eq ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$eq\" , value ) odmantic.query.ne ( field , value ) \u00b6 Source code in odmantic/query.py def ne ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$ne\" , value ) odmantic.query.gt ( field , value ) \u00b6 Source code in odmantic/query.py def gt ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$gt\" , value ) odmantic.query.gte ( field , value ) \u00b6 Source code in odmantic/query.py def gte ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$gte\" , value ) odmantic.query.lt ( field , value ) \u00b6 Source code in odmantic/query.py def lt ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$lt\" , value ) odmantic.query.lte ( field , value ) \u00b6 Source code in odmantic/query.py def lte ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$lte\" , value ) odmantic.query.in_ ( field , value ) \u00b6 Source code in odmantic/query.py def in_ ( field : FieldProxyAny , value : Sequence ) -> QueryExpression : return _cmp_expression ( field , \"$in\" , value ) odmantic.query.not_in ( field , value ) \u00b6 Source code in odmantic/query.py def not_in ( field : FieldProxyAny , value : Sequence ) -> QueryExpression : return _cmp_expression ( field , \"$nin\" , value ) odmantic.query.match ( field , pattern ) \u00b6 Source code in odmantic/query.py def match ( field : FieldProxyAny , pattern : Union [ Pattern , str ]) -> QueryExpression : # FIXME might create incompatibilities # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not if isinstance ( pattern , str ): r = re . compile ( pattern ) else : r = pattern return QueryExpression ({ + field : r })","title":"Query"},{"location":"api_reference/query/#query","text":"","title":"Query"},{"location":"api_reference/query/#odmantic.query.QueryExpression","text":"","title":"QueryExpression"},{"location":"api_reference/query/#logical-operators","text":"","title":"Logical Operators"},{"location":"api_reference/query/#odmantic.query.and_","text":"Source code in odmantic/query.py def and_ ( * elements : Union [ QueryExpression , bool ]) -> QueryExpression : return QueryExpression ({ \"$and\" : elements })","title":"and_()"},{"location":"api_reference/query/#odmantic.query.or_","text":"Source code in odmantic/query.py def or_ ( * elements : Union [ QueryExpression , bool ]) -> QueryExpression : return QueryExpression ({ \"$or\" : elements })","title":"or_()"},{"location":"api_reference/query/#odmantic.query.nor_","text":"Source code in odmantic/query.py def nor_ ( * elements : Union [ QueryExpression , bool ]) -> QueryExpression : return QueryExpression ({ \"$nor\" : elements })","title":"nor_()"},{"location":"api_reference/query/#comparison-operators","text":"","title":"Comparison Operators"},{"location":"api_reference/query/#odmantic.query.eq","text":"Source code in odmantic/query.py def eq ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$eq\" , value )","title":"eq()"},{"location":"api_reference/query/#odmantic.query.ne","text":"Source code in odmantic/query.py def ne ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$ne\" , value )","title":"ne()"},{"location":"api_reference/query/#odmantic.query.gt","text":"Source code in odmantic/query.py def gt ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$gt\" , value )","title":"gt()"},{"location":"api_reference/query/#odmantic.query.gte","text":"Source code in odmantic/query.py def gte ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$gte\" , value )","title":"gte()"},{"location":"api_reference/query/#odmantic.query.lt","text":"Source code in odmantic/query.py def lt ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$lt\" , value )","title":"lt()"},{"location":"api_reference/query/#odmantic.query.lte","text":"Source code in odmantic/query.py def lte ( field : FieldProxyAny , value : Any ) -> QueryExpression : return _cmp_expression ( field , \"$lte\" , value )","title":"lte()"},{"location":"api_reference/query/#odmantic.query.in_","text":"Source code in odmantic/query.py def in_ ( field : FieldProxyAny , value : Sequence ) -> QueryExpression : return _cmp_expression ( field , \"$in\" , value )","title":"in_()"},{"location":"api_reference/query/#odmantic.query.not_in","text":"Source code in odmantic/query.py def not_in ( field : FieldProxyAny , value : Sequence ) -> QueryExpression : return _cmp_expression ( field , \"$nin\" , value )","title":"not_in()"},{"location":"api_reference/query/#odmantic.query.match","text":"Source code in odmantic/query.py def match ( field : FieldProxyAny , pattern : Union [ Pattern , str ]) -> QueryExpression : # FIXME might create incompatibilities # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not if isinstance ( pattern , str ): r = re . compile ( pattern ) else : r = pattern return QueryExpression ({ + field : r })","title":"match()"},{"location":"api_reference/reference/","text":"odmantic.reference.Reference ( * , key_name = None ) \u00b6 Source code in odmantic/reference.py def Reference ( * , key_name : Optional [ str ] = None ) -> Any : return ODMReferenceInfo ( key_name = key_name )","title":"Reference"},{"location":"api_reference/reference/#odmantic.reference.Reference","text":"Source code in odmantic/reference.py def Reference ( * , key_name : Optional [ str ] = None ) -> Any : return ODMReferenceInfo ( key_name = key_name )","title":"Reference()"}]}